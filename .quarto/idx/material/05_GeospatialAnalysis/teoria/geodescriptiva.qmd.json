{"title":"Geodescriptiva","markdown":{"yaml":{"title":"Geodescriptiva","subtitle":"2024 - 2025","title-slide-attributes":{"data-background-image":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToarIkwdutv5YPT_-6EgdYP-LV63oltlKcFQ&s","data-background-size":"contain","data-background-opacity":"0.25","data-background-color":"white"},"author":"Conti, D; Ramirez, S","format":{"revealjs":{"incremental":true,"theme":["night","../../../ideai.scss"],"background-transition":"slide","logo":"../../../imagenes/Logo_UPC.svg.png","css":"../../../logo.css","footer":"Preprocessing i Models Avançats d'Anàlisis de Dades (PMAAD)","controls-tutorial":true,"scale":0.9,"chalkboard":true,"transition":"fade","transitionSpeed":"slow","code-block-height":"650px"}},"editor":"visual"},"headingText":"Introducción","containsRefs":false,"markdown":"\n\n\nLos **datos espaciales**, (datos geográficos o datos georreferenciados), son aquellos que contienen información de una localización o área geográfica de la superficie anclados al espacio.\n\nLa cartografía, el arte de la cartografía, es una habilidad ancestral que implica comunicación, atención al detalle y un componente creativo.\n\nUn mapa cuidadosamente elaborado puede ser la mejor manera de comunicar los resultados de su trabajo, pero un diseño deficiente puede causar una mala impresión.\n\nEntre los problemas de diseño más comunes se incluyen: - la ubicación - el tamaño - la legibilidad deficientes del texto - selección descuidada de colores ([guía de estilos](https://files.taylorandfrancis.com/TJOM-suppmaterial-quick-guide.pdf))\n\nLos mapas de aspecto amateur pueden dificultar la comprensión de información importante por parte del público y debilitar la presentación de una investigación de datos profesional.\n\n## História del análisis geospacial (caso Snow, 1856)\n\nLos mapas se han utilizado durante miles de años para una amplia variedad de propósitos. Algunos ejemplos históricos incluyen mapas de edificios y propiedad de la tierra en la antigua dinastía babilónica, hace más de 3000 años, y el mapamundi de Ptolomeo en su obra maestra , Geografía, hace casi 2000 años.\n\n::::: columns\n::: {.column width=\"60%\"}\nEl primer análisis de datos espaciales fue realizado por el médico John Snow en 1854.\n\n![](https://ichef.bbci.co.uk/ace/ws/640/cpsprodpb/6655/production/_113279162_gettyimages-463899545.jpg.webp){fig-align=\"center\"}\n:::\n\n::: {.column width=\"40%\"}\n![](https://cdn.britannica.com/00/161400-050-E49598A0/John-Snow.jpg){fig-align=\"right\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\nConstruyó un famoso mapa que mostraba las muertes causadas por un brote de cólera.\n\n-   Se detectarón 127 muertes en 3 días\n\n-   Se ubicaban en el barrio del Soho de Londres\n\n-   Se posicionaron las bombas de agua del área\n\n![](https://cdr-book.github.io/img/colera_new.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Solución:\n\nDescubrió que había un agrupamiento significativo de muertes alrededor de una determinada bomba, y al quitar la manija de la bomba se detuvo el brote.\n\n::::: columns\n::: {.column width=\"50%\"}\n![](https://blog.rtwilson.com/wp-content/uploads/2012/01/OSColor_Points.png){fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](https://learn.arcgis.com/es/projects/map-a-historic-cholera-outbreak/GUID-9AF27AFC-17B4-45CE-A31F-B1976C31F2C2-web.png){fig-align=\"center\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\n### Conclusiones\n\nEl análisis espacial de Snow es considerado el antecedente conocido más antiguo de la ciencia de datos, porque:\n\n1.  La información clave se obtuvo mediante\n\n-   las muertes por cólera\n-   las ubicaciones de las bombas de agua\n-   el mapa de calles de Londres\n\n2.  Se puede crear un modelo espacial directamente a partir de los datos\n\n3.  El problema solo se resolvió cuando la evidencia basada en datos se combinó con un modelo plausible que explicaba el fenómeno físico.\n\n# Que és la geostadística? (Marco teórico)\n\n```{r}\n#| label: librerias-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# Librerias de bases de datos\nlibrary(isdas)\nlibrary(idealista18)\nlibrary(CDR)\n\n# Bases de datos de gestión\nlibrary(leaflet)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(classInt)\n\n# Paquetes de geocomputacion\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapSpain)\nlibrary(tidyterra)\nlibrary(giscoR)\nlibrary(terra)\nlibrary(spData)\nlibrary(spDataLarge)\nlibrary(osmdata)\nlibrary(ggmap)\nlibrary(mapview)\nlibrary(tmap)\n```\n\n```{python}\n#| label: librerias-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nfrom plotnine import ggplot, aes, geom_point, coord_fixed, theme_minimal\nfrom plotnine import ggtitle, xlab, ylab\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as ctx\nfrom shapely.geometry import Point\n```\n\n```{r}\n#| label: bbdd-ejemplo-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBCN <- get(data(\"Barcelona_Sale\"))\n\n# Filtramos la epoca a Navidad\nBCN <- BCN[which(BCN$PERIOD == \"201812\"), ]\nsf::st_geometry(BCN) <- \"geometry\"\n```\n\n```{python}\n#| label: bbdd-ejemplo-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npyBCN = r.BCN\n```\n\n------------------------------------------------------------------------\n\n## Estadística para datos espaciales\n\n::: callout-tip\nEl área que se encarga de estudiar y analizar los datos espaciales es la **estadística espacial** o la estadística para datos espaciales.\n:::\n\nDebido a que los datos espaciales surgen en múltiples campos y aplicaciones, hay una gran variedad de tipos de datos, estructuras y escenarios espaciales .\n\nEn 1993, N.A.C Cressie clasificó los datos geospaciales, basado en la naturaleza del dominio espacial, de la siguiente forma:\n\n![](https://cdr-book.github.io/img/cressie_simulados.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Conceptos Clave\n\nA continuación vamos a representar la localización de los inmuebles vendidos por idealista en Barcelona durante el mes de diciembre de 2018.\n\n::::::::: panel-tabset\n## R\n\n::::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\np <- ggplot(data = BCN,\n       aes(x = LONGITUDE, y = LATITUDE)) + \n  geom_point(col=\"blue\", size = 0.1, alpha = 0.3) +\n  coord_fixed()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\nprint(p)\n```\n:::\n:::::\n\n## Python\n\n::::: columns\n::: {.column width=\"65%\"}\n```{python}\n#| label: geo-BCN-Py\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np = (ggplot(pyBCN, aes(x='LONGITUDE', y='LATITUDE')) +\n     geom_point(color='blue', size=0.1, alpha=0.3) +\n     coord_fixed() +\n     theme_minimal() +\n     ggtitle(\"Pisos en Barcelona\") +\n     xlab(\"Longitud\") +\n     ylab(\"Latitud\"))\n```\n:::\n\n::: {.column width=\"35%\"}\n```{python}\n#| label: geo-BCN-Py-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np.show()\n```\n:::\n:::::\n:::::::::\n\n------------------------------------------------------------------------\n\nEn una representación de geodatos o geostadística es importante las siguientes cuestiones:\n\n-   Las **coordendadas**\n\n-   El marco o **contexto espacial**\n\n-   Conocimiento del **sistema de referencia de coordenadas** (*Coordinate reference system* (CRS)) en las que están georreferenciadas o proyectadas las coordenadas\n\n-   Formato de los datos en los que se están trabajando: **vector** o **raster**.\n\n------------------------------------------------------------------------\n\n:::: panel-tabset\n## Gestión de datos con R\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{r}\n#| label: geo-BCN-R-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nidealista2018_sf <- sf::st_as_sf(BCN,\n  coords = c(\"LATITUDE\", \"LONGITUDE\"),\n  crs = 25830) # proyección ETRS89/ UTM zone 30N. Área de uso: Europa    \n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n::: callout-warning\nEl sistema de referencias (CRS) de las coordenadas ha de coincidir con el de los mapas sino no geolocaliza correctamente el punto buscado.\n:::\n\n```{r}\n#| label: geo-BCN-R-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBarcelona <- mapSpain::esp_get_munic(munic = \"^Barcelona$\") |>\n  sf::st_transform(25830) \n\n# descara imagen de un de mapa estático de las carreteas de Madrid\ntile <- maptiles::get_tiles(BCN, provider = \"Esri.WorldStreetMap\", zoom = 10, crop = TRUE)\n\n# tile <- esp_getTiles(Barcelona, \"IGNBase.Gris\", zoommin = 3, verbose = FALSE)\n```\n\n## Mapa con R\n\n```{r}\n#| label: geo-BCN-R-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: screen-inset-right\n\nggplot() +\n  tidyterra::geom_spatraster_rgb(data = tile) +\n  geom_sf(data = idealista2018_sf, \n    col = \"blue\", size = 0.1, alpha = 0.3) +\n  coord_sf(expand = FALSE)\n```\n\n## Gestión de datos con Python\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{python}\n#| label: geo-BCN-py-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 1. Crear GeoDataFrame desde DataFrame (suponiendo que tienes 'LATITUDE' y 'LONGITUDE')\n# Nota: en Python 'LONGITUDE' es x, 'LATITUDE' es y\ngdf = gpd.GeoDataFrame(pyBCN, geometry = gpd.points_from_xy(pyBCN['LONGITUDE'], pyBCN['LATITUDE']), crs = \"EPSG:4326\") # primero en WGS84\n\n# 2. Reproyectar a EPSG:25830\ngdf_utm = gdf.to_crs(epsg = 25830)\n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n```{python}\n#| label: geo-BCN-py-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 3. Definir límites para el mapa base\n# bounds = gdf_utm.total_bounds  # xmin, ymin, xmax, ymax\nbounds = [905729.8210,4580494.7340,958814.7353,4610801.5327]\n```\n\nPodemos buscar el boundary box en la siguiente url: <http://bboxfinder.com/>\n\n## Mapa con Python\n\n```{python}\n#| label: geo-BCN-py-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 4. Plot con mapa base (tiles tipo Esri.WorldStreetMap)\nfig, ax = plt.subplots(figsize = (8, 8))\n\n# Plot puntos\ngdf_utm.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir tiles (contextily necesita CRS compatible, normalmente 3857)\n# Convertir a 3857 para el tile\ngdf_webmerc = gdf_utm.to_crs(epsg = 3857)\nax = gdf_webmerc.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir fondo tipo Esri (o CartoDB, OSM, etc.)\nctx.add_basemap(ax, source = ctx.providers.Esri.WorldStreetMap)\n```\n\n```{python}\n#| label: geo-BCN-py-creacionMapa2\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| panel: sidebar\n\n# Quitar márgenes blancos\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n```\n::::\n\n------------------------------------------------------------------------\n\n### Sistema de referencia de coordenadas\n\nLos **CRS** permiten identificar con exactitud la posición de los datos sobre el globo terráqueo.\n\n:::: fragment\n::: callout-tip\nCuando se trabaja con datos espaciales procedentes de distintas fuentes de información es necesario comprobar que las coordenadas correspondientes a dichos datos se encuentran definidas en el mismo **CRS**.\n:::\n::::\n\n:::: fragment\n::: callout-tip\nEsto se consigue transformándolas (o proyectándolas) a un CRS común.\n:::\n::::\n\n------------------------------------------------------------------------\n\nA continuación se muestra un mapa mundial con la representación en puntos (rojos) de los puertos que existen.\n\n```{r}\n#| label: puertos-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npaises <- gisco_get_countries()\npuertos <- gisco_get_ports()\npaises_robin <- st_transform(paises, st_crs(\"ESRI:54030\")) #Proyección Robinson\n\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos), add = TRUE, col=\"2\", pch=20, lwd=2.5)\n```\n\n¿Que podemos ver en el gráfico?\n\n-   Las coordenadas del mapa y las coordenadas de la base de datos se encuentran en diferentes referencias (CRS)\n\n------------------------------------------------------------------------\n\nLos tipos de CRS que existen son los siguientes:\n\n1.  **Geográficos**: aquellos en los que los parámetros empleados para localizar una posición espacial son:\n\n    -   La **latitud** (Norte-Sur): \\[$-90º, 90º$\\]\n    -   La **longitud** (Este−Oeste): \\[$-180º, 180º$\\]\n    -   Están basados en la geometría esférica (las distancias entre dos puntos son **distancias angulares**)\n\n2.  **Proyectados**: permiten reducir la superficie de la esfera terrestre (3D) a un sistema cartesiano (2D).\n\n    -   Es necesario transformar las coordenadas longitud y latitud en coordenadas cartesianas [^1] X e Y\n    -   La unidad de distancia, habitualmente, es el **metro**\n\n[^1]: Las **coordenadas cartesianas** (sistema cartesiano) son un tipo de coordenadas ortogonales usadas en espacios euclídeos, para la representación gráfica de una relación matemática, movimiento o posición en física, caracterizadas por tener como referencia ejes ortogonales entre sí que concurren en el punto de origen.\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^2] (la proyección cartográfica más popular para mapamundis)\n\n[^2]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n```{r}\n#| label: comprobacion-CRS-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nst_crs(puertos) == st_crs(paises_robin)\n```\n\n```{r}\n#| label: puertos-R-Robinson\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npuertos_robin <- st_transform(puertos, st_crs(paises_robin))\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos_robin), add = TRUE, col = 4, pch = 20)\n```\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^3] (la proyección cartográfica más popular para mapamundis)\n\n[^3]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n:::: fragment\n::: {.callout-tip title=\"R packages\"}\nEl paquete `crsuggest` facilita la elección de la proyección más conveniente, al sugerir transformaciones de sistemas de referencia de coordenadas adecuadas para conjuntos de datos espaciales. Devuelve un marco de datos con códigos CRS que se pueden utilizar para proyectos de transformación y mapeo CRS.\n:::\n::::\n\n![](https://paulblgis.wordpress.com/wp-content/uploads/2016/11/geographic_crs.png){fig-align=\"center\" width=\"507\"}\n\n------------------------------------------------------------------------\n\n## Formatos de datos espaciales\n\nEn el ámbito del análisis espacial los datos espaciales pueden tener formato **vector** (o datos vectoriales) o **formato raster** (*raster* o *rasterizados* o mapa de *bits*).\n\n::: panel-tabset\n### Datos vectoriales\n\nLos **datos vectoriales** pueden representar tres tipos distintos de entidades: puntos, líneas y polígonos, y, quizás, su característica más importante es que cada punto, línea o polígono puede tener una tabla de atributos asociados.\n\n### *Raster*\n\nLos datos ***raster***, son una malla (una matriz) donde cada celda (o *píxel*) tiene un tamaño similar y un valor específico.\n\nCuando se tiene una imagen en color, el raster está compuesto por 3 matrices sobrepuestas, cada una con el valor del color primario correspondiente.\n\nCuando se utilizan imágenes de satélite u otros sensores cada archivo puede contener hasta cientos de matrices que representan distintos rangos de lo observado.\n:::\n\n## Datos vectoriales\n\nEste modelo de datos está basado en puntos **georreferenciados.** Los **puntos**, por ejemplo, representan localizaciones específicas.\n\n```{r}\n#| label: mercadona-R-bbdd\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nq <- getbb(\"Barcelona\") |>\n  opq(timeout = 25 * 100) |>\n  add_osm_feature(\"name\", \"Mercadona\") |>\n  add_osm_feature(\"shop\", \"supermarket\")\n\n# building the query\n# query\nmercadona <- osmdata_sf(q)\n```\n\n```{r}\n#| label: mercadona-R-BCN\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nggplot() +\n  geom_sf(data = mercadona$osm_points, \n          aes(fill = \"Mercadona\"), \n          color = \"lightgreen\") +\n  labs(title = NULL, fill = NULL) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n------------------------------------------------------------------------\n\nLos puntos también pueden estar conectados entre sí, de manera que formen geometrías más complejas, como **líneas** y **polígonos**. El río Tajo está representado como una línea (tajo, sucesión de puntos unidos entre sí) y la ciudad de Toledo como un polígono (toledo, línea de puntos cerrada formando un espacio continuo).\n\n```{r}\n#| label: mercadona-R-Barcelona-completo\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\nggplot(toledo) +\n  geom_sf(fill = \"cornsilk2\") +\n  geom_sf(data = tajo, col = \"lightblue2\", lwd = 2, alpha = 0.7) +\n  geom_sf(data = hosp_toledo, col = \"blue\") +\n  coord_sf(xlim = c(-4.2, -3.8), ylim = c(39.8, 39.95)) +\n  theme_minimal()\n```\n\n![](https://cdr-book.github.io/img/rio-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos de vectores son las siguientes:\n\n| **Tipo**                  | **Extensión**          |\n|---------------------------|------------------------|\n| Shapefile                 | `.shp`, `.shx`, `.dbf` |\n| GeoPackage vector         | `.gpkg`                |\n| GeoJson                   | `.geojson`             |\n| GPX                       | `.gpx`                 |\n| Geography Markup Language | `.gml`                 |\n| Keyhole Markup Language   | `.kml`                 |\n| Otros                     | `.csv`, `.txt`, `xlsx` |\n\n::: {.callout-tip title=\"R packages\"}\n**ESRI Shapefile** surgió como uno de los primeros formatos de intercambio de datos geográficos y en la actualidad es, quizá, el formato más empleado. Sin embargo, tiene una serie de limitaciones: es un formato multiarchivo y el CRS es opcional.\n:::\n\n## Datos en *Raster*\n\nLos **datos raster** son datos proporcionados en una rejilla de píxeles (regulares o no) denominada matriz.\n\nEl caso más popular de un raster es una fotografía. La imagen se representa como una serie de celdas, determinadas por la resolución de la imagen (el tamaño del píxel, 5x5 (regular) y 10x10 (irregular)) y el valor del *píxel* (**RGB** –red, green, blue–) que determina el color que presenta cada uno de estos píxeles.\n\nEn el ámbito de los datos espaciales, un archivo raster está formado por una malla de píxeles georreferenciada.\n\n![](https://cdr-book.github.io/img/elev-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos *raster* son las siguientes:\n\n| **Tipo**                     | **Extensión**   |\n|------------------------------|-----------------|\n| ASCII Grid                   | `.asc`          |\n| GeoTIFF                      | `.tif`, `.tiff` |\n| Enhanced Compression Wavelet | `.ecw`          |\n\nComo ejemplo, vamos a cargar la base de datos de nueva zelanda.\n\n```{r}\n#| label: nz-raster-r\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nnz_elev = rast(system.file(\"raster/nz_elev.tif\", package = \"spDataLarge\"))\n```\n\n# Creación de mapas\n\n------------------------------------------------------------------------\n\nPara poder seguir con la sesión de hoy, necesitaremos instalar el paquete `CDR`. Para ello deberemos de seguir las siguientes indicaciones:\n\n![](https://private-user-images.githubusercontent.com/80209018/274188258-b0583cce-9621-4b37-b157-b576f4450b1c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDQ3NDExMTQsIm5iZiI6MTc0NDc0MDgxNCwicGF0aCI6Ii84MDIwOTAxOC8yNzQxODgyNTgtYjA1ODNjY2UtOTYyMS00YjM3LWIxNTctYjU3NmY0NDUwYjFjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MTUlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDE1VDE4MTMzNFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWYyNmNhMmRlZjk2MjFmYjVmODFmYTNlMGZjNTJjMGMxZmNhOGZkODg1ODE5M2NhZWVmMTNkMGQzZWRkMWZiODkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.zV-56DEmAj2s9iXotYGx5jJwaEUpKIEHVSPr9zSWCeQ){fig-align=\"center\" fig-asp=.5\"}\n\n```{r}\n#| label: cargar-paquete-CDR\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"cdr-book/CDR\")\n```\n\n------------------------------------------------------------------------\n\n## Mapas estáticos\n\nLos mapas estáticos son el tipo de resultado visual más común de la geocomputación. Suelen almacenarse en formatos estándar, como .png y .pdf para salidas gráficas ráster y vectoriales, respectivamente.\n\nLa función genérica `plot()` suele ser la forma más rápida de crear mapas estáticos a partir de objetos espaciales vectoriales y ráster por su simplicidad y la velocidad.\n\n**`tmap`** es un paquete de creación de mapas potente y flexible con valores predeterminados.\n\nSu sintaxis concisa permite crear mapas atractivos con un mínimo de código (muy similar a `ggplot2`). Ofrece la posibilidad de generar mapas estáticos e interactivos utilizando el mismo código mediante `tmap_mode()`.\n\n------------------------------------------------------------------------\n\n### Conceptos básicos\n\n:::::: columns\n::: {.column width=\"33%\"}\n\nAñadir el interior\n\n```{r}\n#| label: mapas-nz-usandoTmap-g1\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ng1 <- tm_shape(nz) +\n  tm_fill() \n```\n:::\n\n::: {.column width=\"33%\"}\n\nAñadir el contorno\n\n```{r}\n#| label: mapas-nz-usandoTmap-g2\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ng2 <- tm_shape(nz) +\n  tm_borders() \n```\n:::\n\n::: {.column width=\"33%\"}\n\nAñadir ambos (También `qtm()`)\n\n```{r}\n#| label: mapas-nz-usandoTmap-g3\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ng3 <- tm_shape(nz) +\n  tm_fill() +\n  tm_borders() \n```\n:::\n::::::\n\n:::::: columns\n::: {.column width=\"33%\"}\n```{r}\n#| label: mapas-nz-usandoTmap-pg1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-asp: 1\n\nprint(g1)\n```\n:::\n\n::: {.column width=\"33%\"}\n```{r}\n#| label: mapas-nz-usandoTmap-pg2\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-asp: 1\n\nprint(g2)\n```\n:::\n\n::: {.column width=\"33%\"}\n```{r}\n#| label: mapas-nz-usandoTmap-pg3\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-asp: 1\n\nprint(g3)\n```\n\n:::\n::::::\n\nVer [https://r.geocompx.org/adv-map](https://r.geocompx.org/adv-map) para saber mas.\n\n------------------------------------------------------------------------\n\n### Mapa de la renta\n\nConcretamente, se representa la distribución de la renta neta per cápita (`renta_municipio_data`) por municipio (`municipios`) en España en el año 2019.\n\nEl primer paso será integrar los ficheros `renta_municipio-data` y `municipios`, los cuales deben tener un campo en común (`codigo_ine`), para unir.\n\n```{r}\n#| label: crear-rentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta <- municipios |>\n  left_join(renta_municipio_data) |>\n  select(name, cpro, cmun, `2019`)    \n```\n\nEl siguiente paso es la representación gráfica de estos datos en el mapa.\n\n```{r}\n#| label: printarrentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ngrafico <- ggplot(munis_renta) +\n  geom_sf(aes(fill = `2019`), color = NA) +\n  scale_fill_continuous(\n    labels = scales::label_number(\n      big.mark = \".\", decimal.mark = \",\", suffix = \" €\" )) +\n  theme_minimal()\nprint(grafico)\n```\n\n------------------------------------------------------------------------\n\nPodemos ver que es un **mapa temático de coropletas**. Un gráfico de coropletas es una visualización sencilla de cómo varía la distribunción de una variable.\n\nSi visualizamos el contenido del objeto `munis_renta` pueden verse una serie de elementos gráficos característicos de los objetos espaciales:\n\n```{r}\n#| label: visualizar-raster-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nhead(munis_renta)[1:3, ]\n```\n\n-   Los datos son de tipo vector\n-   El tipo de geometría es MULTIPOLYGON\n-   El CRS es ETRS89\n-   Leyenda explica el significado de la variable.\n\n## Atención !!! Cuidado cómo se miente en los mapas\n\nA veces, cuando se crea un mapa de coropletas la información puede aparecer distorsionada.\n\nPor ello, para la correcta visualización de los datos que favorezca una interpretación realista es necesario tomar una serie de decisiones:\n\n1.  El número de intervalos (cortes o límites de intervalos) en caso de distribución por intervalos.\n\n2.  La escala de color a utilizar.\n\n3.  El tratamiento de los valores perdidos.\n\n------------------------------------------------------------------------\n\nLos mapas de coropletas muestran la distribución espacial de una variable cuyos valores se dividen en clases o intervalos a los cuales se les aplica un esquema de colores, también llamado **paleta**, dónde a cada clase le corresponde un color de la paleta.\n\nExisten muchas formas para agrupar los valores de una variable en clases pero el **método de Fisher-Jenks** es el más popular en los mapas temáticos y en especial, en los de coropletas.\n\n:::: fragment\n::: {.callout-tip title=\"R packages\"}\nEl método de agrupación de datos de **Fisher-Jenks** utiliza un algoritmo no lineal para agrupar observaciones de modo que se **maximice la homogeneidad dentro del grupo** y la **heterogeneidad entre los mismos**.\n\nEste algoritmo está desarrollado específicamente para la clasificación de datos espaciales y su visualización en mapas.\n:::\n::::\n\n------------------------------------------------------------------------\n\nA continuación, vamos a realizar el mapa de la renta neta per cápita en España, a escala municipal, en 2019 con los intervalos realizados con **Fisher-Jenks**\n\n```{r}\n#| label: bbdd-filtrado-renta-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta_clean <- munis_renta |>\n  filter(!is.na(`2019`))\n```\n\n```{r}\n#| label: cortes-Fisher-Jenks-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# crea Fisher-Jenks clases\nfisher <- classIntervals(munis_renta_clean$`2019`, style = \"fisher\", n = 10)\n```\n\n```{r}\n#| label: mapa-renta-FJ-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nggplot(munis_renta_clean) +\n  geom_sf(aes(fill = cut(`2019`, fisher$brks)), color = NA) +\n            scale_fill_viridis_d(option= \"A\" , \n                                 labels= scales::label_number(suffix= \"€\")) +\nguides(fill = guide_colorsteps()) +\n  labs(fill= \"Fisher-Jenks\") +\ntheme_minimal()\n```\n\n------------------------------------------------------------------------\n\n### Mapa facetados\n\nLos mapas facetados se componen de muchos mapas dispuestos uno junto al otro, y a veces apilados verticalmente.\n\nLas facetas permiten visualizar cómo cambian las relaciones espaciales con respecto a otra variable, como el tiempo.\n\nNormalmente, todas las facetas individuales de un mapa facetado contienen los mismos datos geométricos repetidos varias veces, una por cada columna de los datos de atributos (este es el método de representación gráfica predeterminado para sfobjetos).\n\n------------------------------------------------------------------------\n\n### Mapa facetados\n\nLos mapas facetados se componen de muchos mapas dispuestos uno junto al otro, y a veces apilados verticalmente. \n\nLas facetas permiten visualizar cómo cambian las relaciones espaciales con respecto a otra variable, como el tiempo. \n\nNormalmente, todas las facetas individuales de un mapa facetado contienen los mismos datos geométricos repetidos varias veces, una por cada columna de los datos de atributos (este es el método de representación gráfica predeterminado para sfobjetos). \n\n---\n\n```{r}\n#| label: mapas-facetados\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nurb_1970_2030 = urban_agglomerations |> \n  filter(year %in% c(1970, 1990, 2010, 2030))\n\ntm_shape(world) +\n  tm_polygons() +\n  tm_shape(urb_1970_2030) +\n  tm_symbols(fill = \"black\", col = \"white\", size = \"population_millions\") +\n  tm_facets_wrap(by = \"year\", nrow = 2)\n```\n\n------------------------------------------------------------------------\n\n## Mapas insertados\n\nUn **mapa insertado** es un mapa más pequeño que se representa dentro o junto al mapa principal. Puede tener diversas funciones, como proporcionar contexto o acercar regiones no contiguas para facilitar su comparación.\n\nTambién se pueden usar para enfocar un área más pequeña con más detalle o para cubrir la misma área que el mapa, pero representando un tema diferente.\n\n![](https://r.geocompx.org/figures/insetmap1-1.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLos mapas insertados también se utilizan para crear un mapa de áreas no contiguas. Probablemente, el ejemplo más común es el mapa de Estados Unidos, que incluye los Estados Unidos contiguos, Hawái y Alaska. En estos casos, es fundamental encontrar la mejor proyección para cada recuadro.\n\n```{r}\n#| label: insertados-EEUU\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nus_states_map = tm_shape(us_states, crs = \"EPSG:9311\") + \n  tm_polygons() + \n  tm_layout(frame = FALSE)\n```\n\nEl resto de nuestros objetos, `hawaii` y `alaska`, ya tienen proyecciones adecuadas; por lo tanto, solo necesitamos crear dos mapas separados:\n\n```{r}\n#| label: insertados-hawaii\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nhawaii_map = tm_shape(hawaii) +\n  tm_polygons() + \n  tm_title(\"Hawaii\") +\n  tm_layout(frame = FALSE, bg.color = NA, \n            title.position = c(\"LEFT\", \"BOTTOM\"))\nalaska_map = tm_shape(alaska) +\n  tm_polygons() + \n  tm_title(\"Alaska\") +\n  tm_layout(frame = FALSE, bg.color = NA)\n```\n\n------------------------------------------------------------------------\n\nEl mapa final se crea combinando, redimensionando y organizando estos tres mapas:\n\n```{r}\n#| label: insertado-final\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nus_states_map\nprint(hawaii_map, vp = grid::viewport(0.35, 0.1, width = 0.2, height = 0.1))\nprint(alaska_map, vp = grid::viewport(0.15, 0.15, width = 0.3, height = 0.3))\n```\n\n![](https://r.geocompx.org/figures/insetmap2-1.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n## Mapas espaciotemporales\n\nLa dimensión temporal cobra cada vez más relevancia en el ámbito espacial, y por ello es importante representar en el tiempo los procesos espaciales.\n\nVamos a representar la temperatura mínima registrada en España del 6 al 10 de enero de 2021, durante la Borrasca Filomena.\n\n```{r}\n#| label: crea-bbdd-temperaturas\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ntmin_sf <- st_as_sf(tempmin_data, \n  coords = c(\"longitud\", \"latitud\"),\n  crs = 4326) # coordenadas geográficas longitud/latitud WGS84\n\nesp <- esp_get_ccaa() |> # sf objeto, contorno de España\n        filter(ine.ccaa.name != \"Canarias\") # excluye Canarias\n```\n\n```{r}\n#| label: comprovacion-crs\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nst_crs(tmin_sf) == st_crs(esp)\nesp2 <- st_transform(esp, st_crs(tmin_sf))\nst_crs(tmin_sf) == st_crs(esp2)\n```\n\n------------------------------------------------------------------------\n\nMuestramos la localización de las estaciones que registran la temperatura en España.\n\n```{r}\n#| label: mapa-estaciones\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nggplot(esp2) +\n  geom_sf() +   \n  geom_sf(data = tmin_sf) \n```\n\n------------------------------------------------------------------------\n\nA continuación realizamos el mapa correspondiente a las temperaturas dividido por diferentes dias.\n\n::::: columns\n::: {.column width=\"45%\"}\n```{r}\n#| label: mapa-temperaturas\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\n# definición de intervalos\ncortes <- c(-Inf, seq(-20, 20, 2.5), Inf)\ncolores <- hcl.colors(15, \"PuOr\", rev = TRUE)\n\ntmin_sf_sptem <- tmin_sf |>\n  arrange(fecha, desc(tmin))\n\ngr <- ggplot() +\n  geom_sf(data = esp2, fill = \"grey95\") +\n  geom_sf(data = tmin_sf, aes(color = tmin), \n          size=3, alpha= .7) +\n  facet_wrap(vars(fecha),ncol = 3) + \n  labs(color = \"Temp. mím\") +\n  scale_color_gradientn(\n    colours = colores,\n    breaks = cortes,\n    labels = ~str_c(. , \"º\"),\n    guide = \"legend\") +\n    theme_light()\n```\n:::\n\n::: {.column width=\"55%\"}\n```{r}\n#| label: mapa-temperaturas-print\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nprint(gr)\n```\n:::\n:::::\n\n------------------------------------------------------------------------\n\n## Mapas animados\n\nLos **mapas facetados** permiten mostrar cómo cambian las distribuciones espaciales de las variables pero este enfoque presenta desventajas, que son:\n\n-   Las facetas se vuelven diminutas cuando hay muchas.\n-   cada faceta esté físicamente separada en la pantalla (diferencias sutiles entre ellas pueden ser difíciles de detectar).\n\nLos mapas animados resuelven estos problemas. Esto se puede resolver con el paquete `tmap` (utilizaremos a continuación) o el `gganimate()` de `ggplot2`.\n\n![](https://r.geocompx.org/images/urban-animated.gif){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nA continuación vamos a crear el nuestro gráfico animado:\n\n---\n\n## Mapas animados\n\nLos **mapas facetados** permiten mostrar cómo cambian las distribuciones espaciales de las variables pero este enfoque presenta desventajas, que son: \n\n  - Las facetas se vuelven diminutas cuando hay muchas. \n  - cada faceta esté físicamente separada en la pantalla (diferencias sutiles entre ellas pueden ser difíciles de detectar).\n\nLos mapas animados resuelven estos problemas. Esto se puede resolver con el paquete `tmap` (utilizaremos a continuación) o el `gganimate()` de `ggplot2`. \n\n![](https://r.geocompx.org/images/urban-animated.gif){fig-align=\"center\"}\n\n---\n\nA continuación vamos a crear el nuestro gráfico animado: \n\n```{r}\n#| label: crea-mapa-urbanización\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nurb_anim <- tm_shape(world) + tm_polygons() + \n  tm_shape(urban_agglomerations) + \n  tm_symbols(size = \"population_millions\") +\n  tm_facets_wrap(by = \"year\", nrow = 1, \n                 ncol = 1, free.coords = FALSE)\n```\n\n```{r}\n#| label: crea-mapa-urbanizacion\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ntmap_animation(urb_anim, filename = \"urb_anim.gif\", \n               delay = 25)\n```\n\n![](https://user-images.githubusercontent.com/1825120/38543030-5794b6f0-3c9b-11e8-9da9-10ec1f3ea726.gif){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n## Mapas interactivos\n\nSi bien los mapas estáticos y animados pueden revitalizar los conjuntos de datos geográficos, los mapas interactivos pueden llevarlos a un nuevo nivel.\n\nEl desarrollo de la informática ha propiciado también el desarrollo de la geocomputación, que está relacionada con los desarrollos webs y permite, entre otras cosas, la representación de mapas interactivos.\n\nEstos mapas dinámicos, ampliables y desplazables son más informativos que los mapas estáticos y, además, constituyen una alternativa que puede proporcionar al usuario una experiencia diferente, además de una mayor interacción.\n\n------------------------------------------------------------------------\n\nA través de la función `tmap_mode(\"view\")` nos permite pasar de un mapa estático a un mapa interactivo.\n\n```{r}\n#| label: herramienta-basica\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nmap_nz = tm_shape(nz) + tm_polygons()\ntmap_mode(\"view\")\nmap_nz\n```\n\n------------------------------------------------------------------------\n\n```{r}\n#| label: mapa-interactivo-doble\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nworld_coffee = left_join(world, coffee_data, \n                         by = \"name_long\")\nfacets = c(\"coffee_production_2016\", \"coffee_production_2017\")\ntm_shape(world_coffee) + \n  tm_polygons(facets) + \n  tm_facets_wrap(nrow = 1, sync = TRUE)\n```\n\n------------------------------------------------------------------------\n\n### Otra forma: **mapview**\n\n```{r}\n#| label: modificación-noInteractivo\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ntmap_mode(\"plot\")\n```\n\n```{r}\n#| label: alemania\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\noberfranken = subset(franconia, district == \"Oberfranken\")\ntrails |>\n  st_transform(st_crs(oberfranken)) |>\n  st_intersection(oberfranken) |>\n  st_collection_extract(\"LINESTRING\") |>\n  mapview(color = \"red\", lwd = 3, layer.name = \"trails\") +\n  mapview(franconia, zcol = \"district\") +\n  breweries\n```\n\n------------------------------------------------------------------------\n\n### Mapa de Snow interactivo\n\nVamos a representar la versión interactiva del mapa de Snow. Para ello se utiliza la librería `leaflet.`\n\n::::: columns\n::: {.column width=\"45%\"}\n```{r}\n#| label: mapa-leaflet\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ndata(\"snow_deaths\")\ndata(\"snow_pumps\")\n\n## crea mapa interactivo\nsnow_map <- leaflet() |>\n  setView(lng = -0.136, lat = 51.513, zoom = 16) |>\n  addTiles() |>\n  addMarkers( data = snow_deaths, ~long, ~lat,\n    clusterOptions = markerClusterOptions(),\n    group = \"Deaths\" ) |>\n  addMarkers(data = snow_pumps, ~long, ~lat,\n    group = \"Pumps\" )\n```\n:::\n\n::: {.column width=\"55%\"}\n```{r}\n#| label: mapa-leaflet-print\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nsnow_map\n```\n:::\n:::::\n\n# A tener en cuenta 🗒️\n\n## Referentes actuales del mundo del Geospacial\n\n::::: columns\n::: {.column width=\"25%\"}\n![](https://investigacion.usc.gal/img/uploaded/92537D3790E0868F1CB3340F8B32BE7C.jpg)\n:::\n\n::: {.column width=\"75%\"}\n[Dominic Royé](https://dominicroye.github.io/) Climatólogo y educador de R con un gran compromiso con la comunidad. Su investigación se centra en la biometeorología, entre otros temas, y en la relación entre la salud humana y el medio ambiente atmosférico. Sus proyectos comunitarios valoran la colaboración entre las herramientas de código abierto, la alfabetización de datos y la graficación como una forma de generar poder e impulsar el cambio.\n:::\n:::::\n\n::::: columns\n::: {.column width=\"75%\"}\n[Jakub Nowosad](https://jakubnowosad.com/) Geógrafo computacional y trabaja entre la geocomputación y las ciencias ambientales. Su investigación se centra en el desarrollo y la aplicación de métodos espaciales para ampliar la comprensión de los procesos y patrones ambientales. Parte fundamental de su trabajo es crear, colaborar y mejorar software geocomputacional. Miembro activo de la comunidad `#rspatial` y coautor de los libros *\"Geocomputación con R\"* y *\"Geocomputación con Python\"*.\n:::\n\n::: {.column width=\"25%\"}\n![](https://jakubnowosad.com/static/img/nowosad_by_adrian_wykrota1s.png)\n:::\n:::::\n\n## Bibiligrafia\n\n:::::: columns\n::: {.column width=\"33%\"}\n![](https://geocompx.org/static/img/book_cover_r2.jpg){width=\"60%\"}\n:::\n\n::: {.column width=\"33%\"}\n![](https://geocompx.org/static/img/book_cover_py.png){width=\"60%\"}\n:::\n\n::: {.column width=\"33%\"}\n![](https://geocompx.org/static/img/book_cover_jl.png){width=\"60%\"}\n:::\n::::::\n\nEl proyecto consistió en poder alojar contenido sobre [Geocomputación con R](https://r.geocompx.org/). Desde la publicación de dicho libro en 2019, la comunidad en torno al libro ha crecido e incluye una comunidad emergente llamada *«geocompy»* y el proyecto de libro de código abierto asociado, [Geocomputación con Python](https://py.geocompx.org/). Quedó claro que el nombre *«geocompr»* ya no era apropiado para la naturaleza multilingüe del proyecto.\n\n## Paquetes de R para el Geospacial\n\n## Paquetes de Python para el Geospacial\n\n# ¿Y cuál es el futuro que nos espera?\n\n## Linias futuras\n","srcMarkdownNoYaml":"\n\n## Introducción\n\nLos **datos espaciales**, (datos geográficos o datos georreferenciados), son aquellos que contienen información de una localización o área geográfica de la superficie anclados al espacio.\n\nLa cartografía, el arte de la cartografía, es una habilidad ancestral que implica comunicación, atención al detalle y un componente creativo.\n\nUn mapa cuidadosamente elaborado puede ser la mejor manera de comunicar los resultados de su trabajo, pero un diseño deficiente puede causar una mala impresión.\n\nEntre los problemas de diseño más comunes se incluyen: - la ubicación - el tamaño - la legibilidad deficientes del texto - selección descuidada de colores ([guía de estilos](https://files.taylorandfrancis.com/TJOM-suppmaterial-quick-guide.pdf))\n\nLos mapas de aspecto amateur pueden dificultar la comprensión de información importante por parte del público y debilitar la presentación de una investigación de datos profesional.\n\n## História del análisis geospacial (caso Snow, 1856)\n\nLos mapas se han utilizado durante miles de años para una amplia variedad de propósitos. Algunos ejemplos históricos incluyen mapas de edificios y propiedad de la tierra en la antigua dinastía babilónica, hace más de 3000 años, y el mapamundi de Ptolomeo en su obra maestra , Geografía, hace casi 2000 años.\n\n::::: columns\n::: {.column width=\"60%\"}\nEl primer análisis de datos espaciales fue realizado por el médico John Snow en 1854.\n\n![](https://ichef.bbci.co.uk/ace/ws/640/cpsprodpb/6655/production/_113279162_gettyimages-463899545.jpg.webp){fig-align=\"center\"}\n:::\n\n::: {.column width=\"40%\"}\n![](https://cdn.britannica.com/00/161400-050-E49598A0/John-Snow.jpg){fig-align=\"right\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\nConstruyó un famoso mapa que mostraba las muertes causadas por un brote de cólera.\n\n-   Se detectarón 127 muertes en 3 días\n\n-   Se ubicaban en el barrio del Soho de Londres\n\n-   Se posicionaron las bombas de agua del área\n\n![](https://cdr-book.github.io/img/colera_new.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Solución:\n\nDescubrió que había un agrupamiento significativo de muertes alrededor de una determinada bomba, y al quitar la manija de la bomba se detuvo el brote.\n\n::::: columns\n::: {.column width=\"50%\"}\n![](https://blog.rtwilson.com/wp-content/uploads/2012/01/OSColor_Points.png){fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](https://learn.arcgis.com/es/projects/map-a-historic-cholera-outbreak/GUID-9AF27AFC-17B4-45CE-A31F-B1976C31F2C2-web.png){fig-align=\"center\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\n### Conclusiones\n\nEl análisis espacial de Snow es considerado el antecedente conocido más antiguo de la ciencia de datos, porque:\n\n1.  La información clave se obtuvo mediante\n\n-   las muertes por cólera\n-   las ubicaciones de las bombas de agua\n-   el mapa de calles de Londres\n\n2.  Se puede crear un modelo espacial directamente a partir de los datos\n\n3.  El problema solo se resolvió cuando la evidencia basada en datos se combinó con un modelo plausible que explicaba el fenómeno físico.\n\n# Que és la geostadística? (Marco teórico)\n\n```{r}\n#| label: librerias-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# Librerias de bases de datos\nlibrary(isdas)\nlibrary(idealista18)\nlibrary(CDR)\n\n# Bases de datos de gestión\nlibrary(leaflet)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(classInt)\n\n# Paquetes de geocomputacion\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapSpain)\nlibrary(tidyterra)\nlibrary(giscoR)\nlibrary(terra)\nlibrary(spData)\nlibrary(spDataLarge)\nlibrary(osmdata)\nlibrary(ggmap)\nlibrary(mapview)\nlibrary(tmap)\n```\n\n```{python}\n#| label: librerias-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nfrom plotnine import ggplot, aes, geom_point, coord_fixed, theme_minimal\nfrom plotnine import ggtitle, xlab, ylab\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as ctx\nfrom shapely.geometry import Point\n```\n\n```{r}\n#| label: bbdd-ejemplo-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBCN <- get(data(\"Barcelona_Sale\"))\n\n# Filtramos la epoca a Navidad\nBCN <- BCN[which(BCN$PERIOD == \"201812\"), ]\nsf::st_geometry(BCN) <- \"geometry\"\n```\n\n```{python}\n#| label: bbdd-ejemplo-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npyBCN = r.BCN\n```\n\n------------------------------------------------------------------------\n\n## Estadística para datos espaciales\n\n::: callout-tip\nEl área que se encarga de estudiar y analizar los datos espaciales es la **estadística espacial** o la estadística para datos espaciales.\n:::\n\nDebido a que los datos espaciales surgen en múltiples campos y aplicaciones, hay una gran variedad de tipos de datos, estructuras y escenarios espaciales .\n\nEn 1993, N.A.C Cressie clasificó los datos geospaciales, basado en la naturaleza del dominio espacial, de la siguiente forma:\n\n![](https://cdr-book.github.io/img/cressie_simulados.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Conceptos Clave\n\nA continuación vamos a representar la localización de los inmuebles vendidos por idealista en Barcelona durante el mes de diciembre de 2018.\n\n::::::::: panel-tabset\n## R\n\n::::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\np <- ggplot(data = BCN,\n       aes(x = LONGITUDE, y = LATITUDE)) + \n  geom_point(col=\"blue\", size = 0.1, alpha = 0.3) +\n  coord_fixed()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\nprint(p)\n```\n:::\n:::::\n\n## Python\n\n::::: columns\n::: {.column width=\"65%\"}\n```{python}\n#| label: geo-BCN-Py\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np = (ggplot(pyBCN, aes(x='LONGITUDE', y='LATITUDE')) +\n     geom_point(color='blue', size=0.1, alpha=0.3) +\n     coord_fixed() +\n     theme_minimal() +\n     ggtitle(\"Pisos en Barcelona\") +\n     xlab(\"Longitud\") +\n     ylab(\"Latitud\"))\n```\n:::\n\n::: {.column width=\"35%\"}\n```{python}\n#| label: geo-BCN-Py-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np.show()\n```\n:::\n:::::\n:::::::::\n\n------------------------------------------------------------------------\n\nEn una representación de geodatos o geostadística es importante las siguientes cuestiones:\n\n-   Las **coordendadas**\n\n-   El marco o **contexto espacial**\n\n-   Conocimiento del **sistema de referencia de coordenadas** (*Coordinate reference system* (CRS)) en las que están georreferenciadas o proyectadas las coordenadas\n\n-   Formato de los datos en los que se están trabajando: **vector** o **raster**.\n\n------------------------------------------------------------------------\n\n:::: panel-tabset\n## Gestión de datos con R\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{r}\n#| label: geo-BCN-R-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nidealista2018_sf <- sf::st_as_sf(BCN,\n  coords = c(\"LATITUDE\", \"LONGITUDE\"),\n  crs = 25830) # proyección ETRS89/ UTM zone 30N. Área de uso: Europa    \n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n::: callout-warning\nEl sistema de referencias (CRS) de las coordenadas ha de coincidir con el de los mapas sino no geolocaliza correctamente el punto buscado.\n:::\n\n```{r}\n#| label: geo-BCN-R-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBarcelona <- mapSpain::esp_get_munic(munic = \"^Barcelona$\") |>\n  sf::st_transform(25830) \n\n# descara imagen de un de mapa estático de las carreteas de Madrid\ntile <- maptiles::get_tiles(BCN, provider = \"Esri.WorldStreetMap\", zoom = 10, crop = TRUE)\n\n# tile <- esp_getTiles(Barcelona, \"IGNBase.Gris\", zoommin = 3, verbose = FALSE)\n```\n\n## Mapa con R\n\n```{r}\n#| label: geo-BCN-R-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: screen-inset-right\n\nggplot() +\n  tidyterra::geom_spatraster_rgb(data = tile) +\n  geom_sf(data = idealista2018_sf, \n    col = \"blue\", size = 0.1, alpha = 0.3) +\n  coord_sf(expand = FALSE)\n```\n\n## Gestión de datos con Python\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{python}\n#| label: geo-BCN-py-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 1. Crear GeoDataFrame desde DataFrame (suponiendo que tienes 'LATITUDE' y 'LONGITUDE')\n# Nota: en Python 'LONGITUDE' es x, 'LATITUDE' es y\ngdf = gpd.GeoDataFrame(pyBCN, geometry = gpd.points_from_xy(pyBCN['LONGITUDE'], pyBCN['LATITUDE']), crs = \"EPSG:4326\") # primero en WGS84\n\n# 2. Reproyectar a EPSG:25830\ngdf_utm = gdf.to_crs(epsg = 25830)\n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n```{python}\n#| label: geo-BCN-py-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 3. Definir límites para el mapa base\n# bounds = gdf_utm.total_bounds  # xmin, ymin, xmax, ymax\nbounds = [905729.8210,4580494.7340,958814.7353,4610801.5327]\n```\n\nPodemos buscar el boundary box en la siguiente url: <http://bboxfinder.com/>\n\n## Mapa con Python\n\n```{python}\n#| label: geo-BCN-py-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 4. Plot con mapa base (tiles tipo Esri.WorldStreetMap)\nfig, ax = plt.subplots(figsize = (8, 8))\n\n# Plot puntos\ngdf_utm.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir tiles (contextily necesita CRS compatible, normalmente 3857)\n# Convertir a 3857 para el tile\ngdf_webmerc = gdf_utm.to_crs(epsg = 3857)\nax = gdf_webmerc.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir fondo tipo Esri (o CartoDB, OSM, etc.)\nctx.add_basemap(ax, source = ctx.providers.Esri.WorldStreetMap)\n```\n\n```{python}\n#| label: geo-BCN-py-creacionMapa2\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| panel: sidebar\n\n# Quitar márgenes blancos\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n```\n::::\n\n------------------------------------------------------------------------\n\n### Sistema de referencia de coordenadas\n\nLos **CRS** permiten identificar con exactitud la posición de los datos sobre el globo terráqueo.\n\n:::: fragment\n::: callout-tip\nCuando se trabaja con datos espaciales procedentes de distintas fuentes de información es necesario comprobar que las coordenadas correspondientes a dichos datos se encuentran definidas en el mismo **CRS**.\n:::\n::::\n\n:::: fragment\n::: callout-tip\nEsto se consigue transformándolas (o proyectándolas) a un CRS común.\n:::\n::::\n\n------------------------------------------------------------------------\n\nA continuación se muestra un mapa mundial con la representación en puntos (rojos) de los puertos que existen.\n\n```{r}\n#| label: puertos-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npaises <- gisco_get_countries()\npuertos <- gisco_get_ports()\npaises_robin <- st_transform(paises, st_crs(\"ESRI:54030\")) #Proyección Robinson\n\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos), add = TRUE, col=\"2\", pch=20, lwd=2.5)\n```\n\n¿Que podemos ver en el gráfico?\n\n-   Las coordenadas del mapa y las coordenadas de la base de datos se encuentran en diferentes referencias (CRS)\n\n------------------------------------------------------------------------\n\nLos tipos de CRS que existen son los siguientes:\n\n1.  **Geográficos**: aquellos en los que los parámetros empleados para localizar una posición espacial son:\n\n    -   La **latitud** (Norte-Sur): \\[$-90º, 90º$\\]\n    -   La **longitud** (Este−Oeste): \\[$-180º, 180º$\\]\n    -   Están basados en la geometría esférica (las distancias entre dos puntos son **distancias angulares**)\n\n2.  **Proyectados**: permiten reducir la superficie de la esfera terrestre (3D) a un sistema cartesiano (2D).\n\n    -   Es necesario transformar las coordenadas longitud y latitud en coordenadas cartesianas [^1] X e Y\n    -   La unidad de distancia, habitualmente, es el **metro**\n\n[^1]: Las **coordenadas cartesianas** (sistema cartesiano) son un tipo de coordenadas ortogonales usadas en espacios euclídeos, para la representación gráfica de una relación matemática, movimiento o posición en física, caracterizadas por tener como referencia ejes ortogonales entre sí que concurren en el punto de origen.\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^2] (la proyección cartográfica más popular para mapamundis)\n\n[^2]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n```{r}\n#| label: comprobacion-CRS-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nst_crs(puertos) == st_crs(paises_robin)\n```\n\n```{r}\n#| label: puertos-R-Robinson\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npuertos_robin <- st_transform(puertos, st_crs(paises_robin))\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos_robin), add = TRUE, col = 4, pch = 20)\n```\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^3] (la proyección cartográfica más popular para mapamundis)\n\n[^3]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n:::: fragment\n::: {.callout-tip title=\"R packages\"}\nEl paquete `crsuggest` facilita la elección de la proyección más conveniente, al sugerir transformaciones de sistemas de referencia de coordenadas adecuadas para conjuntos de datos espaciales. Devuelve un marco de datos con códigos CRS que se pueden utilizar para proyectos de transformación y mapeo CRS.\n:::\n::::\n\n![](https://paulblgis.wordpress.com/wp-content/uploads/2016/11/geographic_crs.png){fig-align=\"center\" width=\"507\"}\n\n------------------------------------------------------------------------\n\n## Formatos de datos espaciales\n\nEn el ámbito del análisis espacial los datos espaciales pueden tener formato **vector** (o datos vectoriales) o **formato raster** (*raster* o *rasterizados* o mapa de *bits*).\n\n::: panel-tabset\n### Datos vectoriales\n\nLos **datos vectoriales** pueden representar tres tipos distintos de entidades: puntos, líneas y polígonos, y, quizás, su característica más importante es que cada punto, línea o polígono puede tener una tabla de atributos asociados.\n\n### *Raster*\n\nLos datos ***raster***, son una malla (una matriz) donde cada celda (o *píxel*) tiene un tamaño similar y un valor específico.\n\nCuando se tiene una imagen en color, el raster está compuesto por 3 matrices sobrepuestas, cada una con el valor del color primario correspondiente.\n\nCuando se utilizan imágenes de satélite u otros sensores cada archivo puede contener hasta cientos de matrices que representan distintos rangos de lo observado.\n:::\n\n## Datos vectoriales\n\nEste modelo de datos está basado en puntos **georreferenciados.** Los **puntos**, por ejemplo, representan localizaciones específicas.\n\n```{r}\n#| label: mercadona-R-bbdd\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nq <- getbb(\"Barcelona\") |>\n  opq(timeout = 25 * 100) |>\n  add_osm_feature(\"name\", \"Mercadona\") |>\n  add_osm_feature(\"shop\", \"supermarket\")\n\n# building the query\n# query\nmercadona <- osmdata_sf(q)\n```\n\n```{r}\n#| label: mercadona-R-BCN\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nggplot() +\n  geom_sf(data = mercadona$osm_points, \n          aes(fill = \"Mercadona\"), \n          color = \"lightgreen\") +\n  labs(title = NULL, fill = NULL) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n------------------------------------------------------------------------\n\nLos puntos también pueden estar conectados entre sí, de manera que formen geometrías más complejas, como **líneas** y **polígonos**. El río Tajo está representado como una línea (tajo, sucesión de puntos unidos entre sí) y la ciudad de Toledo como un polígono (toledo, línea de puntos cerrada formando un espacio continuo).\n\n```{r}\n#| label: mercadona-R-Barcelona-completo\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\nggplot(toledo) +\n  geom_sf(fill = \"cornsilk2\") +\n  geom_sf(data = tajo, col = \"lightblue2\", lwd = 2, alpha = 0.7) +\n  geom_sf(data = hosp_toledo, col = \"blue\") +\n  coord_sf(xlim = c(-4.2, -3.8), ylim = c(39.8, 39.95)) +\n  theme_minimal()\n```\n\n![](https://cdr-book.github.io/img/rio-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos de vectores son las siguientes:\n\n| **Tipo**                  | **Extensión**          |\n|---------------------------|------------------------|\n| Shapefile                 | `.shp`, `.shx`, `.dbf` |\n| GeoPackage vector         | `.gpkg`                |\n| GeoJson                   | `.geojson`             |\n| GPX                       | `.gpx`                 |\n| Geography Markup Language | `.gml`                 |\n| Keyhole Markup Language   | `.kml`                 |\n| Otros                     | `.csv`, `.txt`, `xlsx` |\n\n::: {.callout-tip title=\"R packages\"}\n**ESRI Shapefile** surgió como uno de los primeros formatos de intercambio de datos geográficos y en la actualidad es, quizá, el formato más empleado. Sin embargo, tiene una serie de limitaciones: es un formato multiarchivo y el CRS es opcional.\n:::\n\n## Datos en *Raster*\n\nLos **datos raster** son datos proporcionados en una rejilla de píxeles (regulares o no) denominada matriz.\n\nEl caso más popular de un raster es una fotografía. La imagen se representa como una serie de celdas, determinadas por la resolución de la imagen (el tamaño del píxel, 5x5 (regular) y 10x10 (irregular)) y el valor del *píxel* (**RGB** –red, green, blue–) que determina el color que presenta cada uno de estos píxeles.\n\nEn el ámbito de los datos espaciales, un archivo raster está formado por una malla de píxeles georreferenciada.\n\n![](https://cdr-book.github.io/img/elev-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos *raster* son las siguientes:\n\n| **Tipo**                     | **Extensión**   |\n|------------------------------|-----------------|\n| ASCII Grid                   | `.asc`          |\n| GeoTIFF                      | `.tif`, `.tiff` |\n| Enhanced Compression Wavelet | `.ecw`          |\n\nComo ejemplo, vamos a cargar la base de datos de nueva zelanda.\n\n```{r}\n#| label: nz-raster-r\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nnz_elev = rast(system.file(\"raster/nz_elev.tif\", package = \"spDataLarge\"))\n```\n\n# Creación de mapas\n\n------------------------------------------------------------------------\n\nPara poder seguir con la sesión de hoy, necesitaremos instalar el paquete `CDR`. Para ello deberemos de seguir las siguientes indicaciones:\n\n![](https://private-user-images.githubusercontent.com/80209018/274188258-b0583cce-9621-4b37-b157-b576f4450b1c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDQ3NDExMTQsIm5iZiI6MTc0NDc0MDgxNCwicGF0aCI6Ii84MDIwOTAxOC8yNzQxODgyNTgtYjA1ODNjY2UtOTYyMS00YjM3LWIxNTctYjU3NmY0NDUwYjFjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MTUlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDE1VDE4MTMzNFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWYyNmNhMmRlZjk2MjFmYjVmODFmYTNlMGZjNTJjMGMxZmNhOGZkODg1ODE5M2NhZWVmMTNkMGQzZWRkMWZiODkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.zV-56DEmAj2s9iXotYGx5jJwaEUpKIEHVSPr9zSWCeQ){fig-align=\"center\" fig-asp=.5\"}\n\n```{r}\n#| label: cargar-paquete-CDR\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"cdr-book/CDR\")\n```\n\n------------------------------------------------------------------------\n\n## Mapas estáticos\n\nLos mapas estáticos son el tipo de resultado visual más común de la geocomputación. Suelen almacenarse en formatos estándar, como .png y .pdf para salidas gráficas ráster y vectoriales, respectivamente.\n\nLa función genérica `plot()` suele ser la forma más rápida de crear mapas estáticos a partir de objetos espaciales vectoriales y ráster por su simplicidad y la velocidad.\n\n**`tmap`** es un paquete de creación de mapas potente y flexible con valores predeterminados.\n\nSu sintaxis concisa permite crear mapas atractivos con un mínimo de código (muy similar a `ggplot2`). Ofrece la posibilidad de generar mapas estáticos e interactivos utilizando el mismo código mediante `tmap_mode()`.\n\n------------------------------------------------------------------------\n\n### Conceptos básicos\n\n:::::: columns\n::: {.column width=\"33%\"}\n\nAñadir el interior\n\n```{r}\n#| label: mapas-nz-usandoTmap-g1\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ng1 <- tm_shape(nz) +\n  tm_fill() \n```\n:::\n\n::: {.column width=\"33%\"}\n\nAñadir el contorno\n\n```{r}\n#| label: mapas-nz-usandoTmap-g2\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ng2 <- tm_shape(nz) +\n  tm_borders() \n```\n:::\n\n::: {.column width=\"33%\"}\n\nAñadir ambos (También `qtm()`)\n\n```{r}\n#| label: mapas-nz-usandoTmap-g3\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ng3 <- tm_shape(nz) +\n  tm_fill() +\n  tm_borders() \n```\n:::\n::::::\n\n:::::: columns\n::: {.column width=\"33%\"}\n```{r}\n#| label: mapas-nz-usandoTmap-pg1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-asp: 1\n\nprint(g1)\n```\n:::\n\n::: {.column width=\"33%\"}\n```{r}\n#| label: mapas-nz-usandoTmap-pg2\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-asp: 1\n\nprint(g2)\n```\n:::\n\n::: {.column width=\"33%\"}\n```{r}\n#| label: mapas-nz-usandoTmap-pg3\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-asp: 1\n\nprint(g3)\n```\n\n:::\n::::::\n\nVer [https://r.geocompx.org/adv-map](https://r.geocompx.org/adv-map) para saber mas.\n\n------------------------------------------------------------------------\n\n### Mapa de la renta\n\nConcretamente, se representa la distribución de la renta neta per cápita (`renta_municipio_data`) por municipio (`municipios`) en España en el año 2019.\n\nEl primer paso será integrar los ficheros `renta_municipio-data` y `municipios`, los cuales deben tener un campo en común (`codigo_ine`), para unir.\n\n```{r}\n#| label: crear-rentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta <- municipios |>\n  left_join(renta_municipio_data) |>\n  select(name, cpro, cmun, `2019`)    \n```\n\nEl siguiente paso es la representación gráfica de estos datos en el mapa.\n\n```{r}\n#| label: printarrentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ngrafico <- ggplot(munis_renta) +\n  geom_sf(aes(fill = `2019`), color = NA) +\n  scale_fill_continuous(\n    labels = scales::label_number(\n      big.mark = \".\", decimal.mark = \",\", suffix = \" €\" )) +\n  theme_minimal()\nprint(grafico)\n```\n\n------------------------------------------------------------------------\n\nPodemos ver que es un **mapa temático de coropletas**. Un gráfico de coropletas es una visualización sencilla de cómo varía la distribunción de una variable.\n\nSi visualizamos el contenido del objeto `munis_renta` pueden verse una serie de elementos gráficos característicos de los objetos espaciales:\n\n```{r}\n#| label: visualizar-raster-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nhead(munis_renta)[1:3, ]\n```\n\n-   Los datos son de tipo vector\n-   El tipo de geometría es MULTIPOLYGON\n-   El CRS es ETRS89\n-   Leyenda explica el significado de la variable.\n\n## Atención !!! Cuidado cómo se miente en los mapas\n\nA veces, cuando se crea un mapa de coropletas la información puede aparecer distorsionada.\n\nPor ello, para la correcta visualización de los datos que favorezca una interpretación realista es necesario tomar una serie de decisiones:\n\n1.  El número de intervalos (cortes o límites de intervalos) en caso de distribución por intervalos.\n\n2.  La escala de color a utilizar.\n\n3.  El tratamiento de los valores perdidos.\n\n------------------------------------------------------------------------\n\nLos mapas de coropletas muestran la distribución espacial de una variable cuyos valores se dividen en clases o intervalos a los cuales se les aplica un esquema de colores, también llamado **paleta**, dónde a cada clase le corresponde un color de la paleta.\n\nExisten muchas formas para agrupar los valores de una variable en clases pero el **método de Fisher-Jenks** es el más popular en los mapas temáticos y en especial, en los de coropletas.\n\n:::: fragment\n::: {.callout-tip title=\"R packages\"}\nEl método de agrupación de datos de **Fisher-Jenks** utiliza un algoritmo no lineal para agrupar observaciones de modo que se **maximice la homogeneidad dentro del grupo** y la **heterogeneidad entre los mismos**.\n\nEste algoritmo está desarrollado específicamente para la clasificación de datos espaciales y su visualización en mapas.\n:::\n::::\n\n------------------------------------------------------------------------\n\nA continuación, vamos a realizar el mapa de la renta neta per cápita en España, a escala municipal, en 2019 con los intervalos realizados con **Fisher-Jenks**\n\n```{r}\n#| label: bbdd-filtrado-renta-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta_clean <- munis_renta |>\n  filter(!is.na(`2019`))\n```\n\n```{r}\n#| label: cortes-Fisher-Jenks-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# crea Fisher-Jenks clases\nfisher <- classIntervals(munis_renta_clean$`2019`, style = \"fisher\", n = 10)\n```\n\n```{r}\n#| label: mapa-renta-FJ-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nggplot(munis_renta_clean) +\n  geom_sf(aes(fill = cut(`2019`, fisher$brks)), color = NA) +\n            scale_fill_viridis_d(option= \"A\" , \n                                 labels= scales::label_number(suffix= \"€\")) +\nguides(fill = guide_colorsteps()) +\n  labs(fill= \"Fisher-Jenks\") +\ntheme_minimal()\n```\n\n------------------------------------------------------------------------\n\n### Mapa facetados\n\nLos mapas facetados se componen de muchos mapas dispuestos uno junto al otro, y a veces apilados verticalmente.\n\nLas facetas permiten visualizar cómo cambian las relaciones espaciales con respecto a otra variable, como el tiempo.\n\nNormalmente, todas las facetas individuales de un mapa facetado contienen los mismos datos geométricos repetidos varias veces, una por cada columna de los datos de atributos (este es el método de representación gráfica predeterminado para sfobjetos).\n\n------------------------------------------------------------------------\n\n### Mapa facetados\n\nLos mapas facetados se componen de muchos mapas dispuestos uno junto al otro, y a veces apilados verticalmente. \n\nLas facetas permiten visualizar cómo cambian las relaciones espaciales con respecto a otra variable, como el tiempo. \n\nNormalmente, todas las facetas individuales de un mapa facetado contienen los mismos datos geométricos repetidos varias veces, una por cada columna de los datos de atributos (este es el método de representación gráfica predeterminado para sfobjetos). \n\n---\n\n```{r}\n#| label: mapas-facetados\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nurb_1970_2030 = urban_agglomerations |> \n  filter(year %in% c(1970, 1990, 2010, 2030))\n\ntm_shape(world) +\n  tm_polygons() +\n  tm_shape(urb_1970_2030) +\n  tm_symbols(fill = \"black\", col = \"white\", size = \"population_millions\") +\n  tm_facets_wrap(by = \"year\", nrow = 2)\n```\n\n------------------------------------------------------------------------\n\n## Mapas insertados\n\nUn **mapa insertado** es un mapa más pequeño que se representa dentro o junto al mapa principal. Puede tener diversas funciones, como proporcionar contexto o acercar regiones no contiguas para facilitar su comparación.\n\nTambién se pueden usar para enfocar un área más pequeña con más detalle o para cubrir la misma área que el mapa, pero representando un tema diferente.\n\n![](https://r.geocompx.org/figures/insetmap1-1.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLos mapas insertados también se utilizan para crear un mapa de áreas no contiguas. Probablemente, el ejemplo más común es el mapa de Estados Unidos, que incluye los Estados Unidos contiguos, Hawái y Alaska. En estos casos, es fundamental encontrar la mejor proyección para cada recuadro.\n\n```{r}\n#| label: insertados-EEUU\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nus_states_map = tm_shape(us_states, crs = \"EPSG:9311\") + \n  tm_polygons() + \n  tm_layout(frame = FALSE)\n```\n\nEl resto de nuestros objetos, `hawaii` y `alaska`, ya tienen proyecciones adecuadas; por lo tanto, solo necesitamos crear dos mapas separados:\n\n```{r}\n#| label: insertados-hawaii\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nhawaii_map = tm_shape(hawaii) +\n  tm_polygons() + \n  tm_title(\"Hawaii\") +\n  tm_layout(frame = FALSE, bg.color = NA, \n            title.position = c(\"LEFT\", \"BOTTOM\"))\nalaska_map = tm_shape(alaska) +\n  tm_polygons() + \n  tm_title(\"Alaska\") +\n  tm_layout(frame = FALSE, bg.color = NA)\n```\n\n------------------------------------------------------------------------\n\nEl mapa final se crea combinando, redimensionando y organizando estos tres mapas:\n\n```{r}\n#| label: insertado-final\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nus_states_map\nprint(hawaii_map, vp = grid::viewport(0.35, 0.1, width = 0.2, height = 0.1))\nprint(alaska_map, vp = grid::viewport(0.15, 0.15, width = 0.3, height = 0.3))\n```\n\n![](https://r.geocompx.org/figures/insetmap2-1.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n## Mapas espaciotemporales\n\nLa dimensión temporal cobra cada vez más relevancia en el ámbito espacial, y por ello es importante representar en el tiempo los procesos espaciales.\n\nVamos a representar la temperatura mínima registrada en España del 6 al 10 de enero de 2021, durante la Borrasca Filomena.\n\n```{r}\n#| label: crea-bbdd-temperaturas\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ntmin_sf <- st_as_sf(tempmin_data, \n  coords = c(\"longitud\", \"latitud\"),\n  crs = 4326) # coordenadas geográficas longitud/latitud WGS84\n\nesp <- esp_get_ccaa() |> # sf objeto, contorno de España\n        filter(ine.ccaa.name != \"Canarias\") # excluye Canarias\n```\n\n```{r}\n#| label: comprovacion-crs\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nst_crs(tmin_sf) == st_crs(esp)\nesp2 <- st_transform(esp, st_crs(tmin_sf))\nst_crs(tmin_sf) == st_crs(esp2)\n```\n\n------------------------------------------------------------------------\n\nMuestramos la localización de las estaciones que registran la temperatura en España.\n\n```{r}\n#| label: mapa-estaciones\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nggplot(esp2) +\n  geom_sf() +   \n  geom_sf(data = tmin_sf) \n```\n\n------------------------------------------------------------------------\n\nA continuación realizamos el mapa correspondiente a las temperaturas dividido por diferentes dias.\n\n::::: columns\n::: {.column width=\"45%\"}\n```{r}\n#| label: mapa-temperaturas\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\n# definición de intervalos\ncortes <- c(-Inf, seq(-20, 20, 2.5), Inf)\ncolores <- hcl.colors(15, \"PuOr\", rev = TRUE)\n\ntmin_sf_sptem <- tmin_sf |>\n  arrange(fecha, desc(tmin))\n\ngr <- ggplot() +\n  geom_sf(data = esp2, fill = \"grey95\") +\n  geom_sf(data = tmin_sf, aes(color = tmin), \n          size=3, alpha= .7) +\n  facet_wrap(vars(fecha),ncol = 3) + \n  labs(color = \"Temp. mím\") +\n  scale_color_gradientn(\n    colours = colores,\n    breaks = cortes,\n    labels = ~str_c(. , \"º\"),\n    guide = \"legend\") +\n    theme_light()\n```\n:::\n\n::: {.column width=\"55%\"}\n```{r}\n#| label: mapa-temperaturas-print\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nprint(gr)\n```\n:::\n:::::\n\n------------------------------------------------------------------------\n\n## Mapas animados\n\nLos **mapas facetados** permiten mostrar cómo cambian las distribuciones espaciales de las variables pero este enfoque presenta desventajas, que son:\n\n-   Las facetas se vuelven diminutas cuando hay muchas.\n-   cada faceta esté físicamente separada en la pantalla (diferencias sutiles entre ellas pueden ser difíciles de detectar).\n\nLos mapas animados resuelven estos problemas. Esto se puede resolver con el paquete `tmap` (utilizaremos a continuación) o el `gganimate()` de `ggplot2`.\n\n![](https://r.geocompx.org/images/urban-animated.gif){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nA continuación vamos a crear el nuestro gráfico animado:\n\n---\n\n## Mapas animados\n\nLos **mapas facetados** permiten mostrar cómo cambian las distribuciones espaciales de las variables pero este enfoque presenta desventajas, que son: \n\n  - Las facetas se vuelven diminutas cuando hay muchas. \n  - cada faceta esté físicamente separada en la pantalla (diferencias sutiles entre ellas pueden ser difíciles de detectar).\n\nLos mapas animados resuelven estos problemas. Esto se puede resolver con el paquete `tmap` (utilizaremos a continuación) o el `gganimate()` de `ggplot2`. \n\n![](https://r.geocompx.org/images/urban-animated.gif){fig-align=\"center\"}\n\n---\n\nA continuación vamos a crear el nuestro gráfico animado: \n\n```{r}\n#| label: crea-mapa-urbanización\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nurb_anim <- tm_shape(world) + tm_polygons() + \n  tm_shape(urban_agglomerations) + \n  tm_symbols(size = \"population_millions\") +\n  tm_facets_wrap(by = \"year\", nrow = 1, \n                 ncol = 1, free.coords = FALSE)\n```\n\n```{r}\n#| label: crea-mapa-urbanizacion\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ntmap_animation(urb_anim, filename = \"urb_anim.gif\", \n               delay = 25)\n```\n\n![](https://user-images.githubusercontent.com/1825120/38543030-5794b6f0-3c9b-11e8-9da9-10ec1f3ea726.gif){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n## Mapas interactivos\n\nSi bien los mapas estáticos y animados pueden revitalizar los conjuntos de datos geográficos, los mapas interactivos pueden llevarlos a un nuevo nivel.\n\nEl desarrollo de la informática ha propiciado también el desarrollo de la geocomputación, que está relacionada con los desarrollos webs y permite, entre otras cosas, la representación de mapas interactivos.\n\nEstos mapas dinámicos, ampliables y desplazables son más informativos que los mapas estáticos y, además, constituyen una alternativa que puede proporcionar al usuario una experiencia diferente, además de una mayor interacción.\n\n------------------------------------------------------------------------\n\nA través de la función `tmap_mode(\"view\")` nos permite pasar de un mapa estático a un mapa interactivo.\n\n```{r}\n#| label: herramienta-basica\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nmap_nz = tm_shape(nz) + tm_polygons()\ntmap_mode(\"view\")\nmap_nz\n```\n\n------------------------------------------------------------------------\n\n```{r}\n#| label: mapa-interactivo-doble\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nworld_coffee = left_join(world, coffee_data, \n                         by = \"name_long\")\nfacets = c(\"coffee_production_2016\", \"coffee_production_2017\")\ntm_shape(world_coffee) + \n  tm_polygons(facets) + \n  tm_facets_wrap(nrow = 1, sync = TRUE)\n```\n\n------------------------------------------------------------------------\n\n### Otra forma: **mapview**\n\n```{r}\n#| label: modificación-noInteractivo\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\ntmap_mode(\"plot\")\n```\n\n```{r}\n#| label: alemania\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\noberfranken = subset(franconia, district == \"Oberfranken\")\ntrails |>\n  st_transform(st_crs(oberfranken)) |>\n  st_intersection(oberfranken) |>\n  st_collection_extract(\"LINESTRING\") |>\n  mapview(color = \"red\", lwd = 3, layer.name = \"trails\") +\n  mapview(franconia, zcol = \"district\") +\n  breweries\n```\n\n------------------------------------------------------------------------\n\n### Mapa de Snow interactivo\n\nVamos a representar la versión interactiva del mapa de Snow. Para ello se utiliza la librería `leaflet.`\n\n::::: columns\n::: {.column width=\"45%\"}\n```{r}\n#| label: mapa-leaflet\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ndata(\"snow_deaths\")\ndata(\"snow_pumps\")\n\n## crea mapa interactivo\nsnow_map <- leaflet() |>\n  setView(lng = -0.136, lat = 51.513, zoom = 16) |>\n  addTiles() |>\n  addMarkers( data = snow_deaths, ~long, ~lat,\n    clusterOptions = markerClusterOptions(),\n    group = \"Deaths\" ) |>\n  addMarkers(data = snow_pumps, ~long, ~lat,\n    group = \"Pumps\" )\n```\n:::\n\n::: {.column width=\"55%\"}\n```{r}\n#| label: mapa-leaflet-print\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nsnow_map\n```\n:::\n:::::\n\n# A tener en cuenta 🗒️\n\n## Referentes actuales del mundo del Geospacial\n\n::::: columns\n::: {.column width=\"25%\"}\n![](https://investigacion.usc.gal/img/uploaded/92537D3790E0868F1CB3340F8B32BE7C.jpg)\n:::\n\n::: {.column width=\"75%\"}\n[Dominic Royé](https://dominicroye.github.io/) Climatólogo y educador de R con un gran compromiso con la comunidad. Su investigación se centra en la biometeorología, entre otros temas, y en la relación entre la salud humana y el medio ambiente atmosférico. Sus proyectos comunitarios valoran la colaboración entre las herramientas de código abierto, la alfabetización de datos y la graficación como una forma de generar poder e impulsar el cambio.\n:::\n:::::\n\n::::: columns\n::: {.column width=\"75%\"}\n[Jakub Nowosad](https://jakubnowosad.com/) Geógrafo computacional y trabaja entre la geocomputación y las ciencias ambientales. Su investigación se centra en el desarrollo y la aplicación de métodos espaciales para ampliar la comprensión de los procesos y patrones ambientales. Parte fundamental de su trabajo es crear, colaborar y mejorar software geocomputacional. Miembro activo de la comunidad `#rspatial` y coautor de los libros *\"Geocomputación con R\"* y *\"Geocomputación con Python\"*.\n:::\n\n::: {.column width=\"25%\"}\n![](https://jakubnowosad.com/static/img/nowosad_by_adrian_wykrota1s.png)\n:::\n:::::\n\n## Bibiligrafia\n\n:::::: columns\n::: {.column width=\"33%\"}\n![](https://geocompx.org/static/img/book_cover_r2.jpg){width=\"60%\"}\n:::\n\n::: {.column width=\"33%\"}\n![](https://geocompx.org/static/img/book_cover_py.png){width=\"60%\"}\n:::\n\n::: {.column width=\"33%\"}\n![](https://geocompx.org/static/img/book_cover_jl.png){width=\"60%\"}\n:::\n::::::\n\nEl proyecto consistió en poder alojar contenido sobre [Geocomputación con R](https://r.geocompx.org/). Desde la publicación de dicho libro en 2019, la comunidad en torno al libro ha crecido e incluye una comunidad emergente llamada *«geocompy»* y el proyecto de libro de código abierto asociado, [Geocomputación con Python](https://py.geocompx.org/). Quedó claro que el nombre *«geocompr»* ya no era apropiado para la naturaleza multilingüe del proyecto.\n\n## Paquetes de R para el Geospacial\n\n## Paquetes de Python para el Geospacial\n\n# ¿Y cuál es el futuro que nos espera?\n\n## Linias futuras\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","incremental":true,"css":["../../../logo.css"],"output-file":"geodescriptiva.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.37","auto-stretch":true,"title":"Geodescriptiva","subtitle":"2024 - 2025","title-slide-attributes":{"data-background-image":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToarIkwdutv5YPT_-6EgdYP-LV63oltlKcFQ&s","data-background-size":"contain","data-background-opacity":"0.25","data-background-color":"white"},"author":"Conti, D; Ramirez, S","editor":"visual","theme":["night","../../../ideai.scss"],"backgroundTransition":"slide","logo":"../../../imagenes/Logo_UPC.svg.png","footer":"Preprocessing i Models Avançats d'Anàlisis de Dades (PMAAD)","controlsTutorial":true,"scale":0.9,"chalkboard":true,"transition":"fade","transitionSpeed":"slow","code-block-height":"650px"}}},"projectFormats":["html"]}