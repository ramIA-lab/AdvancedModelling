{"title":"Geodescriptiva","markdown":{"yaml":{"title":"Geodescriptiva","subtitle":"2024 - 2025","title-slide-attributes":{"data-background-image":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToarIkwdutv5YPT_-6EgdYP-LV63oltlKcFQ&s","data-background-size":"contain","data-background-opacity":"0.25","data-background-color":"white"},"author":"Conti, D; Ramirez, S","format":{"revealjs":{"incremental":true,"theme":["night","../../../ideai.scss"],"background-transition":"slide","logo":"../../../imagenes/Logo_UPC.svg.png","css":"../../../logo.css","footer":"Preprocessing i Models Avançats d'Anàlisis de Dades (PMAAD)","controls-tutorial":true,"scale":0.9,"chalkboard":true,"transition":"fade","transitionSpeed":"slow","code-block-height":"650px"}},"editor":"visual"},"headingText":"Introducción","containsRefs":false,"markdown":"\n\n\nLos **datos espaciales**, (datos geográficos o datos georreferenciados), son aquellos que contienen información de una localización o área geográfica de la superficie anclados al espacio.\n\n## História del análisis geospacial (Snow, 1856)\n\n::::: columns\n::: {.column width=\"60%\"}\nEl primer análisis de datos espaciales fue realizado por el médico John Snow en 1854.\n\n![](https://ichef.bbci.co.uk/ace/ws/640/cpsprodpb/6655/production/_113279162_gettyimages-463899545.jpg.webp){fig-align=\"center\"}\n:::\n\n::: {.column width=\"40%\"}\n![](https://cdn.britannica.com/00/161400-050-E49598A0/John-Snow.jpg){fig-align=\"right\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\nConstruyó un famoso mapa que mostraba las muertes causadas por un brote de cólera.\n\n-   Se detectarón 127 muertes en 3 días\n\n-   Se ubicaban en el barrio del Soho de Londres\n\n-   Se posicionaron las bombas de agua del área\n\n![](https://cdr-book.github.io/img/colera_new.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Solución:\n\nDescubrió que había un agrupamiento significativo de muertes alrededor de una determinada bomba, y al quitar la manija de la bomba se detuvo el brote.\n\n::::: columns\n::: {.column width=\"50%\"}\n![](https://blog.rtwilson.com/wp-content/uploads/2012/01/OSColor_Points.png){fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](https://learn.arcgis.com/es/projects/map-a-historic-cholera-outbreak/GUID-9AF27AFC-17B4-45CE-A31F-B1976C31F2C2-web.png){fig-align=\"center\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\n### Conclusiones\n\nEl análisis espacial de Snow es considerado el antecedente conocido más antiguo de la ciencia de datos, porque:\n\n1.  La información clave se obtuvo mediante\n\n-   las muertes por cólera\n-   las ubicaciones de las bombas de agua\n-   el mapa de calles de Londres\n\n2.  Se puede crear un modelo espacial directamente a partir de los datos\n\n3.  El problema solo se resolvió cuando la evidencia basada en datos se combinó con un modelo plausible que explicaba el fenómeno físico.\n\n# Que és la geostadística? (Marco teórico)\n\n```{r}\n#| label: librerias-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nlibrary(idealista18)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapSpain)\nlibrary(tidyterra)\nlibrary(giscoR)\n\nlibrary(tidyverse)\nlibrary(osmdata)\nlibrary(ggmap)\n\nlibrary(CDR)\n\nlibrary(classInt)\n```\n\n```{python}\n#| label: librerias-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nfrom plotnine import ggplot, aes, geom_point, coord_fixed, theme_minimal\nfrom plotnine import ggtitle, xlab, ylab\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as ctx\nfrom shapely.geometry import Point\n```\n\n```{r}\n#| label: bbdd-ejemplo-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBCN <- get(data(\"Barcelona_Sale\"))\n\n# Filtramos la epoca a Navidad\nBCN <- BCN[which(BCN$PERIOD == \"201812\"), ]\nsf::st_geometry(BCN) <- \"geometry\"\n```\n\n```{python}\n#| label: bbdd-ejemplo-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npyBCN = r.BCN\n```\n\n------------------------------------------------------------------------\n\n## Estadística para datos espaciales\n\n::: callout-tip\nEl área que se encarga de estudiar y analizar los datos espaciales es la **estadística espacial** o la estadística para datos espaciales.\n:::\n\nDebido a que los datos espaciales surgen en múltiples campos y aplicaciones, hay una gran variedad de tipos de datos, estructuras y escenarios espaciales .\n\nEn 1993, N.A.C Cressie clasificó los datos geospaciales, basado en la naturaleza del dominio espacial, de la siguiente forma:\n\n![](https://cdr-book.github.io/img/cressie_simulados.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Conceptos Clave\n\nA continuación vamos a representar la localización de los inmuebles vendidos por idealista en Barcelona durante el mes de diciembre de 2018.\n\n::::::::: panel-tabset\n## R\n\n::::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\np <- ggplot(data = BCN,\n       aes(x = LONGITUDE, y = LATITUDE)) + \n  geom_point(col=\"blue\", size = 0.1, alpha = 0.3) +\n  coord_fixed()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\nprint(p)\n```\n:::\n:::::\n\n## Python\n\n::::: columns\n::: {.column width=\"65%\"}\n```{python}\n#| label: geo-BCN-Py\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np = (ggplot(pyBCN, aes(x='LONGITUDE', y='LATITUDE')) +\n     geom_point(color='blue', size=0.1, alpha=0.3) +\n     coord_fixed() +\n     theme_minimal() +\n     ggtitle(\"Pisos en Barcelona\") +\n     xlab(\"Longitud\") +\n     ylab(\"Latitud\"))\n```\n:::\n\n::: {.column width=\"35%\"}\n```{python}\n#| label: geo-BCN-Py-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np.show()\n```\n:::\n:::::\n:::::::::\n\n------------------------------------------------------------------------\n\nEn una representación de geodatos o geostadística es importante las siguientes cuestiones:\n\n-   Las **coordendadas**\n\n-   El marco o **contexto espacial**\n\n-   Conocimiento del **sistema de referencia de coordenadas** (*Coordinate reference system* (CRS)) en las que están georreferenciadas o proyectadas las coordenadas\n\n-   Formato de los datos en los que se están trabajando: **vector** o **raster**.\n\n------------------------------------------------------------------------\n\n:::: panel-tabset\n## Gestión de datos con R\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{r}\n#| label: geo-BCN-R-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nidealista2018_sf <- sf::st_as_sf(BCN,\n  coords = c(\"LATITUDE\", \"LONGITUDE\"),\n  crs = 25830) # proyección ETRS89/ UTM zone 30N. Área de uso: Europa    \n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n::: callout-warning\nEl sistema de referencias (CRS) de las coordenadas ha de coincidir con el de los mapas sino no geolocaliza correctamente el punto buscado.\n:::\n\n```{r}\n#| label: geo-BCN-R-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBarcelona <- mapSpain::esp_get_munic(munic = \"^Barcelona$\") |>\n  sf::st_transform(25830) \n\n# descara imagen de un de mapa estático de las carreteas de Madrid\ntile <- maptiles::get_tiles(BCN, provider = \"Esri.WorldStreetMap\", zoom = 10, crop = TRUE)\n\n# tile <- esp_getTiles(Barcelona, \"IGNBase.Gris\", zoommin = 3, verbose = FALSE)\n```\n\n## Mapa con R\n\n```{r}\n#| label: geo-BCN-R-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: screen-inset-right\n\nggplot() +\n  tidyterra::geom_spatraster_rgb(data = tile) +\n  geom_sf(data = idealista2018_sf, \n    col = \"blue\", size = 0.1, alpha = 0.3) +\n  coord_sf(expand = FALSE)\n```\n\n## Gestión de datos con Python\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{python}\n#| label: geo-BCN-py-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 1. Crear GeoDataFrame desde DataFrame (suponiendo que tienes 'LATITUDE' y 'LONGITUDE')\n# Nota: en Python 'LONGITUDE' es x, 'LATITUDE' es y\ngdf = gpd.GeoDataFrame(pyBCN, geometry = gpd.points_from_xy(pyBCN['LONGITUDE'], pyBCN['LATITUDE']), crs = \"EPSG:4326\") # primero en WGS84\n\n# 2. Reproyectar a EPSG:25830\ngdf_utm = gdf.to_crs(epsg = 25830)\n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n```{python}\n#| label: geo-BCN-py-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 3. Definir límites para el mapa base\n# bounds = gdf_utm.total_bounds  # xmin, ymin, xmax, ymax\nbounds = [905729.8210,4580494.7340,958814.7353,4610801.5327]\n```\n\nPodemos buscar el boundary box en la siguiente url: <http://bboxfinder.com/>\n\n## Mapa con Python\n\n```{python}\n#| label: geo-BCN-py-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 4. Plot con mapa base (tiles tipo Esri.WorldStreetMap)\nfig, ax = plt.subplots(figsize = (8, 8))\n\n# Plot puntos\ngdf_utm.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir tiles (contextily necesita CRS compatible, normalmente 3857)\n# Convertir a 3857 para el tile\ngdf_webmerc = gdf_utm.to_crs(epsg = 3857)\nax = gdf_webmerc.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir fondo tipo Esri (o CartoDB, OSM, etc.)\nctx.add_basemap(ax, source = ctx.providers.Esri.WorldStreetMap)\n```\n\n```{python}\n#| label: geo-BCN-py-creacionMapa2\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| panel: sidebar\n\n# Quitar márgenes blancos\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n```\n::::\n\n------------------------------------------------------------------------\n\n### Sistema de referencia de coordenadas\n\nLos **CRS** permiten identificar con exactitud la posición de los datos sobre el globo terráqueo.\n\n:::: fragment\n::: callout-tip\nCuando se trabaja con datos espaciales procedentes de distintas fuentes de información es necesario comprobar que las coordenadas correspondientes a dichos datos se encuentran definidas en el mismo **CRS**.\n:::\n::::\n\n:::: fragment\n::: callout-tip\nEsto se consigue transformándolas (o proyectándolas) a un CRS común.\n:::\n::::\n\n------------------------------------------------------------------------\n\nA continuación se muestra un mapa mundial con la representación en puntos (rojos) de los puertos que existen.\n\n```{r}\n#| label: puertos-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npaises <- gisco_get_countries()\npuertos <- gisco_get_ports()\npaises_robin <- st_transform(paises, st_crs(\"ESRI:54030\")) #Proyección Robinson\n\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos), add = TRUE, col=\"2\", pch=20, lwd=2.5)\n```\n\n¿Que podemos ver en el gráfico?\n\n-   Las coordenadas del mapa y las coordenadas de la base de datos se encuentran en diferentes referencias (CRS)\n\n------------------------------------------------------------------------\n\nLos tipos de CRS que existen son los siguientes:\n\n1.  **Geográficos**: aquellos en los que los parámetros empleados para localizar una posición espacial son:\n\n    -   La **latitud** (Norte-Sur): \\[$-90º, 90º$\\]\n    -   La **longitud** (Este−Oeste): \\[$-180º, 180º$\\]\n    -   Están basados en la geometría esférica (las distancias entre dos puntos son **distancias angulares**)\n\n2.  **Proyectados**: permiten reducir la superficie de la esfera terrestre (3D) a un sistema cartesiano (2D).\n\n    -   Es necesario transformar las coordenadas longitud y latitud en coordenadas cartesianas [^1] X e Y\n    -   La unidad de distancia, habitualmente, es el **metro**\n\n[^1]: Las **coordenadas cartesianas** (sistema cartesiano) son un tipo de coordenadas ortogonales usadas en espacios euclídeos, para la representación gráfica de una relación matemática, movimiento o posición en física, caracterizadas por tener como referencia ejes ortogonales entre sí que concurren en el punto de origen.\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^2] (la proyección cartográfica más popular para mapamundis)\n\n[^2]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n```{r}\n#| label: comprobacion-CRS-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nst_crs(puertos) == st_crs(paises_robin)\n```\n\n```{r}\n#| label: puertos-R-Robinson\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npuertos_robin <- st_transform(puertos, st_crs(paises_robin))\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos_robin), add = TRUE, col = 4, pch = 20)\n```\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^3] (la proyección cartográfica más popular para mapamundis)\n\n[^3]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n:::: fragment\n::: {.callout-tip title=\"R packages\"}\nEl paquete `crsuggest` facilita la elección de la proyección más conveniente, al sugerir transformaciones de sistemas de referencia de coordenadas adecuadas para conjuntos de datos espaciales. Devuelve un marco de datos con códigos CRS que se pueden utilizar para proyectos de transformación y mapeo CRS.\n:::\n::::\n\n![](https://paulblgis.wordpress.com/wp-content/uploads/2016/11/geographic_crs.png){fig-align=\"center\" width=\"507\"}\n\n------------------------------------------------------------------------\n\n## Formatos de datos espaciales\n\nEn el ámbito del análisis espacial los datos espaciales pueden tener formato **vector** (o datos vectoriales) o **formato raster** (*raster* o *rasterizados* o mapa de *bits*).\n\n::: panel-tabset\n### Datos vectoriales\n\nLos **datos vectoriales** pueden representar tres tipos distintos de entidades: puntos, líneas y polígonos, y, quizás, su característica más importante es que cada punto, línea o polígono puede tener una tabla de atributos asociados.\n\n### *Raster*\n\nLos datos ***raster***, son una malla (una matriz) donde cada celda (o *píxel*) tiene un tamaño similar y un valor específico.\n\nCuando se tiene una imagen en color, el raster está compuesto por 3 matrices sobrepuestas, cada una con el valor del color primario correspondiente.\n\nCuando se utilizan imágenes de satélite u otros sensores cada archivo puede contener hasta cientos de matrices que representan distintos rangos de lo observado.\n:::\n\n## Datos vectoriales\n\nEste modelo de datos está basado en puntos **georreferenciados.** Los **puntos**, por ejemplo, representan localizaciones específicas.\n\n```{r}\n#| label: mercadona-R-bbdd\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nq <- getbb(\"Barcelona\") |>\n  opq(timeout = 25 * 100) |>\n  add_osm_feature(\"name\", \"Mercadona\") |>\n  add_osm_feature(\"shop\", \"supermarket\")\n\n# building the query\n# query\nmercadona <- osmdata_sf(q)\n```\n\n```{r}\n#| label: mercadona-R-BCN\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nggplot() +\n  geom_sf(data = mercadona$osm_points, \n          aes(fill = \"Mercadona\"), \n          color = \"lightgreen\") +\n  labs(title = NULL, fill = NULL) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n------------------------------------------------------------------------\n\nLos puntos también pueden estar conectados entre sí, de manera que formen geometrías más complejas, como **líneas** y **polígonos**. El río Tajo está representado como una línea (tajo, sucesión de puntos unidos entre sí) y la ciudad de Toledo como un polígono (toledo, línea de puntos cerrada formando un espacio continuo).\n\n```{r}\n#| label: mercadona-R-Barcelona-completo\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\nggplot(toledo) +\n  geom_sf(fill = \"cornsilk2\") +\n  geom_sf(data = tajo, col = \"lightblue2\", lwd = 2, alpha = 0.7) +\n  geom_sf(data = hosp_toledo, col = \"blue\") +\n  coord_sf(xlim = c(-4.2, -3.8), ylim = c(39.8, 39.95)) +\n  theme_minimal()\n```\n\n![](https://cdr-book.github.io/img/rio-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos de vectores son las siguientes:\n\n| **Tipo**                  | **Extensión**          |\n|---------------------------|------------------------|\n| Shapefile                 | `.shp`, `.shx`, `.dbf` |\n| GeoPackage vector         | `.gpkg`                |\n| GeoJson                   | `.geojson`             |\n| GPX                       | `.gpx`                 |\n| Geography Markup Language | `.gml`                 |\n| Keyhole Markup Language   | `.kml`                 |\n| Otros                     | `.csv`, `.txt`, `xlsx` |\n\n::: {.callout-tip title=\"R packages\"}\n**ESRI Shapefile** surgió como uno de los primeros formatos de intercambio de datos geográficos y en la actualidad es, quizá, el formato más empleado. Sin embargo, tiene una serie de limitaciones: es un formato multiarchivo y el CRS es opcional.\n:::\n\n## Datos en *Raster*\n\nLos **datos raster** son datos proporcionados en una rejilla de píxeles (regulares o no) denominada matriz.\n\nEl caso más popular de un raster es una fotografía. La imagen se representa como una serie de celdas, determinadas por la resolución de la imagen (el tamaño del píxel, 5x5 (regular) y 10x10 (irregular)) y el valor del *píxel* (**RGB** –red, green, blue–) que determina el color que presenta cada uno de estos píxeles.\n\nEn el ámbito de los datos espaciales, un archivo raster está formado por una malla de píxeles georreferenciada.\n\n![](https://cdr-book.github.io/img/elev-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos *raster* son las siguientes:\n\n| **Tipo**                     | **Extensión**   |\n|------------------------------|-----------------|\n| ASCII Grid                   | `.asc`          |\n| GeoTIFF                      | `.tif`, `.tiff` |\n| Enhanced Compression Wavelet | `.ecw`          |\n\n# Creación de mapas\n\n------------------------------------------------------------------------\n\nPara poder seguir con la sesión de hoy, necesitaremos instalar el paquete `CDR`. Para ello deberemos de seguir las siguientes indicaciones:\n\n![](https://private-user-images.githubusercontent.com/80209018/274188258-b0583cce-9621-4b37-b157-b576f4450b1c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDQ3NDExMTQsIm5iZiI6MTc0NDc0MDgxNCwicGF0aCI6Ii84MDIwOTAxOC8yNzQxODgyNTgtYjA1ODNjY2UtOTYyMS00YjM3LWIxNTctYjU3NmY0NDUwYjFjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MTUlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDE1VDE4MTMzNFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWYyNmNhMmRlZjk2MjFmYjVmODFmYTNlMGZjNTJjMGMxZmNhOGZkODg1ODE5M2NhZWVmMTNkMGQzZWRkMWZiODkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.zV-56DEmAj2s9iXotYGx5jJwaEUpKIEHVSPr9zSWCeQ){fig-align=\"center\" width=\"50%\"}\n\n```{r}\n#| label: cargar-paquete-CDR\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"cdr-book/CDR\")\n```\n\n---\n\nConcretamente, se representa la distribución de la renta neta per cápita (`renta_municipio_data`) por municipio (`municipios`) en España en el año 2019.\n\nEl primer paso será integrar los ficheros `renta_municipio-data` y `municipios`, los cuales deben tener un campo en común (`codigo_ine`), para unir. \n\n```{r}\n#| label: crear-rentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta <- municipios |>\n  left_join(renta_municipio_data) |>\n  select(name, cpro, cmun, `2019`)    \n```\n\nEl siguiente paso es la representación gráfica de estos datos en el mapa.\n\n```{r}\n#| label: printarrentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ngrafico <- ggplot(munis_renta) +\n  geom_sf(aes(fill = `2019`), color = NA) +\n  scale_fill_continuous(\n    labels = scales::label_number(\n      big.mark = \".\", decimal.mark = \",\", suffix = \" €\" )) +\n  theme_minimal()\nprint(grafico)\n```\n\n---\n\nPodemos ver que es un **mapa temático de coropletas**. Un gráfico de coropletas es una visualización sencilla de cómo varía la distribunción de una variable. \n\nSi visualizamos el contenido del objeto `munis_renta` pueden verse una serie de elementos gráficos característicos de los objetos espaciales:\n\n```{r}\n#| label: visualizar-raster-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nhead(munis_renta)[1:3, ]\n```\n\n  - Los datos son de tipo vector\n  - El tipo de geometría es MULTIPOLYGON\n  - El CRS es ETRS89 \n  - Leyenda explica el significado de la variable.\n\n## Atención !!! Cuidado cómo se miente en los mapas\n\nA veces, cuando se crea un mapa de coropletas la información puede aparecer distorsionada. \n\nPor ello, para la correcta visualización de los datos que favorezca una interpretación realista es necesario tomar una serie de decisiones:\n\n1. El número de intervalos (cortes o límites de intervalos) en caso de distribución por intervalos.\n\n2. La escala de color a utilizar.\n\n3. El tratamiento de los valores perdidos.\n\n---\n\nLos mapas de coropletas muestran la distribución espacial de una variable cuyos valores se dividen en clases o intervalos a los cuales se les aplica un esquema de colores, también llamado **paleta**, dónde a cada clase le corresponde un color de la paleta. \n\nExisten muchas formas para agrupar los valores de una variable en clases pero el **método de Fisher-Jenks** es el más popular en los mapas temáticos y en especial, en los de coropletas.\n\n::::{.fragment}\n::: {.callout-tip title=\"R packages\"}\nEl método de agrupación de datos de **Fisher-Jenks** utiliza un algoritmo no lineal para agrupar observaciones de modo que se **maximice la homogeneidad dentro del grupo** y la **heterogeneidad entre los mismos**. \n\nEste algoritmo está desarrollado específicamente para la clasificación de datos espaciales y su visualización en mapas.\n:::\n::::\n\n---\n\nA continuación, vamos a realizar el mapa de la renta neta per cápita en España, a escala municipal, en 2019 con los intervalos realizados con **Fisher-Jenks**\n\n```{r}\n#| label: bbdd-filtrado-renta-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta_clean <- munis_renta |>\n  filter(!is.na(`2019`))\n```\n\n\n```{r}\n#| label: cortes-Fisher-Jenks-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# crea Fisher-Jenks clases\nfisher <- classIntervals(munis_renta_clean$`2019`, style = \"fisher\", n = 10)\n```\n\n\n```{r}\n#| label: mapa-renta-FJ-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nggplot(munis_renta_clean) +\n  geom_sf(aes(fill = cut(`2019`, fisher$brks)), color = NA) +\n            scale_fill_viridis_d(option= \"A\" , \n                                 labels= scales::label_number(suffix= \"€\")) +\nguides(fill = guide_colorsteps()) +\n  labs(fill= \"Fisher-Jenks\") +\ntheme_minimal()\n```\n\n## Mapas espaciotemporales\n\n## Mapas animados\n\n## Mapas interactivos\n","srcMarkdownNoYaml":"\n\n## Introducción\n\nLos **datos espaciales**, (datos geográficos o datos georreferenciados), son aquellos que contienen información de una localización o área geográfica de la superficie anclados al espacio.\n\n## História del análisis geospacial (Snow, 1856)\n\n::::: columns\n::: {.column width=\"60%\"}\nEl primer análisis de datos espaciales fue realizado por el médico John Snow en 1854.\n\n![](https://ichef.bbci.co.uk/ace/ws/640/cpsprodpb/6655/production/_113279162_gettyimages-463899545.jpg.webp){fig-align=\"center\"}\n:::\n\n::: {.column width=\"40%\"}\n![](https://cdn.britannica.com/00/161400-050-E49598A0/John-Snow.jpg){fig-align=\"right\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\nConstruyó un famoso mapa que mostraba las muertes causadas por un brote de cólera.\n\n-   Se detectarón 127 muertes en 3 días\n\n-   Se ubicaban en el barrio del Soho de Londres\n\n-   Se posicionaron las bombas de agua del área\n\n![](https://cdr-book.github.io/img/colera_new.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Solución:\n\nDescubrió que había un agrupamiento significativo de muertes alrededor de una determinada bomba, y al quitar la manija de la bomba se detuvo el brote.\n\n::::: columns\n::: {.column width=\"50%\"}\n![](https://blog.rtwilson.com/wp-content/uploads/2012/01/OSColor_Points.png){fig-align=\"center\"}\n:::\n\n::: {.column width=\"50%\"}\n![](https://learn.arcgis.com/es/projects/map-a-historic-cholera-outbreak/GUID-9AF27AFC-17B4-45CE-A31F-B1976C31F2C2-web.png){fig-align=\"center\"}\n:::\n:::::\n\n------------------------------------------------------------------------\n\n### Conclusiones\n\nEl análisis espacial de Snow es considerado el antecedente conocido más antiguo de la ciencia de datos, porque:\n\n1.  La información clave se obtuvo mediante\n\n-   las muertes por cólera\n-   las ubicaciones de las bombas de agua\n-   el mapa de calles de Londres\n\n2.  Se puede crear un modelo espacial directamente a partir de los datos\n\n3.  El problema solo se resolvió cuando la evidencia basada en datos se combinó con un modelo plausible que explicaba el fenómeno físico.\n\n# Que és la geostadística? (Marco teórico)\n\n```{r}\n#| label: librerias-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nlibrary(idealista18)\nlibrary(ggplot2)\nlibrary(sf)\nlibrary(maptiles)\nlibrary(mapSpain)\nlibrary(tidyterra)\nlibrary(giscoR)\n\nlibrary(tidyverse)\nlibrary(osmdata)\nlibrary(ggmap)\n\nlibrary(CDR)\n\nlibrary(classInt)\n```\n\n```{python}\n#| label: librerias-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nfrom plotnine import ggplot, aes, geom_point, coord_fixed, theme_minimal\nfrom plotnine import ggtitle, xlab, ylab\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport contextily as ctx\nfrom shapely.geometry import Point\n```\n\n```{r}\n#| label: bbdd-ejemplo-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBCN <- get(data(\"Barcelona_Sale\"))\n\n# Filtramos la epoca a Navidad\nBCN <- BCN[which(BCN$PERIOD == \"201812\"), ]\nsf::st_geometry(BCN) <- \"geometry\"\n```\n\n```{python}\n#| label: bbdd-ejemplo-Py\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npyBCN = r.BCN\n```\n\n------------------------------------------------------------------------\n\n## Estadística para datos espaciales\n\n::: callout-tip\nEl área que se encarga de estudiar y analizar los datos espaciales es la **estadística espacial** o la estadística para datos espaciales.\n:::\n\nDebido a que los datos espaciales surgen en múltiples campos y aplicaciones, hay una gran variedad de tipos de datos, estructuras y escenarios espaciales .\n\nEn 1993, N.A.C Cressie clasificó los datos geospaciales, basado en la naturaleza del dominio espacial, de la siguiente forma:\n\n![](https://cdr-book.github.io/img/cressie_simulados.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\n### Conceptos Clave\n\nA continuación vamos a representar la localización de los inmuebles vendidos por idealista en Barcelona durante el mes de diciembre de 2018.\n\n::::::::: panel-tabset\n## R\n\n::::: columns\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\np <- ggplot(data = BCN,\n       aes(x = LONGITUDE, y = LATITUDE)) + \n  geom_point(col=\"blue\", size = 0.1, alpha = 0.3) +\n  coord_fixed()\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\n#| label: geo-BCN-R-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: margin\n\nprint(p)\n```\n:::\n:::::\n\n## Python\n\n::::: columns\n::: {.column width=\"65%\"}\n```{python}\n#| label: geo-BCN-Py\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np = (ggplot(pyBCN, aes(x='LONGITUDE', y='LATITUDE')) +\n     geom_point(color='blue', size=0.1, alpha=0.3) +\n     coord_fixed() +\n     theme_minimal() +\n     ggtitle(\"Pisos en Barcelona\") +\n     xlab(\"Longitud\") +\n     ylab(\"Latitud\"))\n```\n:::\n\n::: {.column width=\"35%\"}\n```{python}\n#| label: geo-BCN-Py-plot1\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\np.show()\n```\n:::\n:::::\n:::::::::\n\n------------------------------------------------------------------------\n\nEn una representación de geodatos o geostadística es importante las siguientes cuestiones:\n\n-   Las **coordendadas**\n\n-   El marco o **contexto espacial**\n\n-   Conocimiento del **sistema de referencia de coordenadas** (*Coordinate reference system* (CRS)) en las que están georreferenciadas o proyectadas las coordenadas\n\n-   Formato de los datos en los que se están trabajando: **vector** o **raster**.\n\n------------------------------------------------------------------------\n\n:::: panel-tabset\n## Gestión de datos con R\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{r}\n#| label: geo-BCN-R-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nidealista2018_sf <- sf::st_as_sf(BCN,\n  coords = c(\"LATITUDE\", \"LONGITUDE\"),\n  crs = 25830) # proyección ETRS89/ UTM zone 30N. Área de uso: Europa    \n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n::: callout-warning\nEl sistema de referencias (CRS) de las coordenadas ha de coincidir con el de los mapas sino no geolocaliza correctamente el punto buscado.\n:::\n\n```{r}\n#| label: geo-BCN-R-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nBarcelona <- mapSpain::esp_get_munic(munic = \"^Barcelona$\") |>\n  sf::st_transform(25830) \n\n# descara imagen de un de mapa estático de las carreteas de Madrid\ntile <- maptiles::get_tiles(BCN, provider = \"Esri.WorldStreetMap\", zoom = 10, crop = TRUE)\n\n# tile <- esp_getTiles(Barcelona, \"IGNBase.Gris\", zoommin = 3, verbose = FALSE)\n```\n\n## Mapa con R\n\n```{r}\n#| label: geo-BCN-R-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| column: screen-inset-right\n\nggplot() +\n  tidyterra::geom_spatraster_rgb(data = tile) +\n  geom_sf(data = idealista2018_sf, \n    col = \"blue\", size = 0.1, alpha = 0.3) +\n  coord_sf(expand = FALSE)\n```\n\n## Gestión de datos con Python\n\nCambiamos el sistema de referencia de coordenadas al sistema de referencia (CRS) Europeo.\n\n```{python}\n#| label: geo-BCN-py-cambiarCRS\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 1. Crear GeoDataFrame desde DataFrame (suponiendo que tienes 'LATITUDE' y 'LONGITUDE')\n# Nota: en Python 'LONGITUDE' es x, 'LATITUDE' es y\ngdf = gpd.GeoDataFrame(pyBCN, geometry = gpd.points_from_xy(pyBCN['LONGITUDE'], pyBCN['LATITUDE']), crs = \"EPSG:4326\") # primero en WGS84\n\n# 2. Reproyectar a EPSG:25830\ngdf_utm = gdf.to_crs(epsg = 25830)\n```\n\nGeneramos el mapa estático para poder representar nuestra información en él.\n\n```{python}\n#| label: geo-BCN-py-descargarMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 3. Definir límites para el mapa base\n# bounds = gdf_utm.total_bounds  # xmin, ymin, xmax, ymax\nbounds = [905729.8210,4580494.7340,958814.7353,4610801.5327]\n```\n\nPodemos buscar el boundary box en la siguiente url: <http://bboxfinder.com/>\n\n## Mapa con Python\n\n```{python}\n#| label: geo-BCN-py-creacionMapa\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# 4. Plot con mapa base (tiles tipo Esri.WorldStreetMap)\nfig, ax = plt.subplots(figsize = (8, 8))\n\n# Plot puntos\ngdf_utm.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir tiles (contextily necesita CRS compatible, normalmente 3857)\n# Convertir a 3857 para el tile\ngdf_webmerc = gdf_utm.to_crs(epsg = 3857)\nax = gdf_webmerc.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)\n\n# Añadir fondo tipo Esri (o CartoDB, OSM, etc.)\nctx.add_basemap(ax, source = ctx.providers.Esri.WorldStreetMap)\n```\n\n```{python}\n#| label: geo-BCN-py-creacionMapa2\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| panel: sidebar\n\n# Quitar márgenes blancos\nax.set_axis_off()\nplt.tight_layout()\nplt.show()\n```\n::::\n\n------------------------------------------------------------------------\n\n### Sistema de referencia de coordenadas\n\nLos **CRS** permiten identificar con exactitud la posición de los datos sobre el globo terráqueo.\n\n:::: fragment\n::: callout-tip\nCuando se trabaja con datos espaciales procedentes de distintas fuentes de información es necesario comprobar que las coordenadas correspondientes a dichos datos se encuentran definidas en el mismo **CRS**.\n:::\n::::\n\n:::: fragment\n::: callout-tip\nEsto se consigue transformándolas (o proyectándolas) a un CRS común.\n:::\n::::\n\n------------------------------------------------------------------------\n\nA continuación se muestra un mapa mundial con la representación en puntos (rojos) de los puertos que existen.\n\n```{r}\n#| label: puertos-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npaises <- gisco_get_countries()\npuertos <- gisco_get_ports()\npaises_robin <- st_transform(paises, st_crs(\"ESRI:54030\")) #Proyección Robinson\n\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos), add = TRUE, col=\"2\", pch=20, lwd=2.5)\n```\n\n¿Que podemos ver en el gráfico?\n\n-   Las coordenadas del mapa y las coordenadas de la base de datos se encuentran en diferentes referencias (CRS)\n\n------------------------------------------------------------------------\n\nLos tipos de CRS que existen son los siguientes:\n\n1.  **Geográficos**: aquellos en los que los parámetros empleados para localizar una posición espacial son:\n\n    -   La **latitud** (Norte-Sur): \\[$-90º, 90º$\\]\n    -   La **longitud** (Este−Oeste): \\[$-180º, 180º$\\]\n    -   Están basados en la geometría esférica (las distancias entre dos puntos son **distancias angulares**)\n\n2.  **Proyectados**: permiten reducir la superficie de la esfera terrestre (3D) a un sistema cartesiano (2D).\n\n    -   Es necesario transformar las coordenadas longitud y latitud en coordenadas cartesianas [^1] X e Y\n    -   La unidad de distancia, habitualmente, es el **metro**\n\n[^1]: Las **coordenadas cartesianas** (sistema cartesiano) son un tipo de coordenadas ortogonales usadas en espacios euclídeos, para la representación gráfica de una relación matemática, movimiento o posición en física, caracterizadas por tener como referencia ejes ortogonales entre sí que concurren en el punto de origen.\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^2] (la proyección cartográfica más popular para mapamundis)\n\n[^2]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n```{r}\n#| label: comprobacion-CRS-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nst_crs(puertos) == st_crs(paises_robin)\n```\n\n```{r}\n#| label: puertos-R-Robinson\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\npuertos_robin <- st_transform(puertos, st_crs(paises_robin))\nplot(st_geometry(paises_robin), main = \" \")\nplot(st_geometry(puertos_robin), add = TRUE, col = 4, pch = 20)\n```\n\n------------------------------------------------------------------------\n\nSeguimos con el ejemplo de los puertos marítimos y proyectamos los puertos en el mismo CRS que el mapamundi utilizando la proyección de Robinson[^3] (la proyección cartográfica más popular para mapamundis)\n\n[^3]: proyección cartográfica que representa el mundo en un plano, diseñada para minimizar la distorsión de las formas y tamaños de los continentes y océanos\n\n:::: fragment\n::: {.callout-tip title=\"R packages\"}\nEl paquete `crsuggest` facilita la elección de la proyección más conveniente, al sugerir transformaciones de sistemas de referencia de coordenadas adecuadas para conjuntos de datos espaciales. Devuelve un marco de datos con códigos CRS que se pueden utilizar para proyectos de transformación y mapeo CRS.\n:::\n::::\n\n![](https://paulblgis.wordpress.com/wp-content/uploads/2016/11/geographic_crs.png){fig-align=\"center\" width=\"507\"}\n\n------------------------------------------------------------------------\n\n## Formatos de datos espaciales\n\nEn el ámbito del análisis espacial los datos espaciales pueden tener formato **vector** (o datos vectoriales) o **formato raster** (*raster* o *rasterizados* o mapa de *bits*).\n\n::: panel-tabset\n### Datos vectoriales\n\nLos **datos vectoriales** pueden representar tres tipos distintos de entidades: puntos, líneas y polígonos, y, quizás, su característica más importante es que cada punto, línea o polígono puede tener una tabla de atributos asociados.\n\n### *Raster*\n\nLos datos ***raster***, son una malla (una matriz) donde cada celda (o *píxel*) tiene un tamaño similar y un valor específico.\n\nCuando se tiene una imagen en color, el raster está compuesto por 3 matrices sobrepuestas, cada una con el valor del color primario correspondiente.\n\nCuando se utilizan imágenes de satélite u otros sensores cada archivo puede contener hasta cientos de matrices que representan distintos rangos de lo observado.\n:::\n\n## Datos vectoriales\n\nEste modelo de datos está basado en puntos **georreferenciados.** Los **puntos**, por ejemplo, representan localizaciones específicas.\n\n```{r}\n#| label: mercadona-R-bbdd\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nq <- getbb(\"Barcelona\") |>\n  opq(timeout = 25 * 100) |>\n  add_osm_feature(\"name\", \"Mercadona\") |>\n  add_osm_feature(\"shop\", \"supermarket\")\n\n# building the query\n# query\nmercadona <- osmdata_sf(q)\n```\n\n```{r}\n#| label: mercadona-R-BCN\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nggplot() +\n  geom_sf(data = mercadona$osm_points, \n          aes(fill = \"Mercadona\"), \n          color = \"lightgreen\") +\n  labs(title = NULL, fill = NULL) +\n  theme_minimal() +\n  theme(legend.position = \"right\")\n```\n\n------------------------------------------------------------------------\n\nLos puntos también pueden estar conectados entre sí, de manera que formen geometrías más complejas, como **líneas** y **polígonos**. El río Tajo está representado como una línea (tajo, sucesión de puntos unidos entre sí) y la ciudad de Toledo como un polígono (toledo, línea de puntos cerrada formando un espacio continuo).\n\n```{r}\n#| label: mercadona-R-Barcelona-completo\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\nggplot(toledo) +\n  geom_sf(fill = \"cornsilk2\") +\n  geom_sf(data = tajo, col = \"lightblue2\", lwd = 2, alpha = 0.7) +\n  geom_sf(data = hosp_toledo, col = \"blue\") +\n  coord_sf(xlim = c(-4.2, -3.8), ylim = c(39.8, 39.95)) +\n  theme_minimal()\n```\n\n![](https://cdr-book.github.io/img/rio-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos de vectores son las siguientes:\n\n| **Tipo**                  | **Extensión**          |\n|---------------------------|------------------------|\n| Shapefile                 | `.shp`, `.shx`, `.dbf` |\n| GeoPackage vector         | `.gpkg`                |\n| GeoJson                   | `.geojson`             |\n| GPX                       | `.gpx`                 |\n| Geography Markup Language | `.gml`                 |\n| Keyhole Markup Language   | `.kml`                 |\n| Otros                     | `.csv`, `.txt`, `xlsx` |\n\n::: {.callout-tip title=\"R packages\"}\n**ESRI Shapefile** surgió como uno de los primeros formatos de intercambio de datos geográficos y en la actualidad es, quizá, el formato más empleado. Sin embargo, tiene una serie de limitaciones: es un formato multiarchivo y el CRS es opcional.\n:::\n\n## Datos en *Raster*\n\nLos **datos raster** son datos proporcionados en una rejilla de píxeles (regulares o no) denominada matriz.\n\nEl caso más popular de un raster es una fotografía. La imagen se representa como una serie de celdas, determinadas por la resolución de la imagen (el tamaño del píxel, 5x5 (regular) y 10x10 (irregular)) y el valor del *píxel* (**RGB** –red, green, blue–) que determina el color que presenta cada uno de estos píxeles.\n\nEn el ámbito de los datos espaciales, un archivo raster está formado por una malla de píxeles georreferenciada.\n\n![](https://cdr-book.github.io/img/elev-toledo.png){fig-align=\"center\"}\n\n------------------------------------------------------------------------\n\nLas extensiones más habituales de los archivos que contienen datos *raster* son las siguientes:\n\n| **Tipo**                     | **Extensión**   |\n|------------------------------|-----------------|\n| ASCII Grid                   | `.asc`          |\n| GeoTIFF                      | `.tif`, `.tiff` |\n| Enhanced Compression Wavelet | `.ecw`          |\n\n# Creación de mapas\n\n------------------------------------------------------------------------\n\nPara poder seguir con la sesión de hoy, necesitaremos instalar el paquete `CDR`. Para ello deberemos de seguir las siguientes indicaciones:\n\n![](https://private-user-images.githubusercontent.com/80209018/274188258-b0583cce-9621-4b37-b157-b576f4450b1c.png?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3NDQ3NDExMTQsIm5iZiI6MTc0NDc0MDgxNCwicGF0aCI6Ii84MDIwOTAxOC8yNzQxODgyNTgtYjA1ODNjY2UtOTYyMS00YjM3LWIxNTctYjU3NmY0NDUwYjFjLnBuZz9YLUFtei1BbGdvcml0aG09QVdTNC1ITUFDLVNIQTI1NiZYLUFtei1DcmVkZW50aWFsPUFLSUFWQ09EWUxTQTUzUFFLNFpBJTJGMjAyNTA0MTUlMkZ1cy1lYXN0LTElMkZzMyUyRmF3czRfcmVxdWVzdCZYLUFtei1EYXRlPTIwMjUwNDE1VDE4MTMzNFomWC1BbXotRXhwaXJlcz0zMDAmWC1BbXotU2lnbmF0dXJlPWYyNmNhMmRlZjk2MjFmYjVmODFmYTNlMGZjNTJjMGMxZmNhOGZkODg1ODE5M2NhZWVmMTNkMGQzZWRkMWZiODkmWC1BbXotU2lnbmVkSGVhZGVycz1ob3N0In0.zV-56DEmAj2s9iXotYGx5jJwaEUpKIEHVSPr9zSWCeQ){fig-align=\"center\" width=\"50%\"}\n\n```{r}\n#| label: cargar-paquete-CDR\n#| echo: true\n#| eval: false\n#| warning: false\n#| message: false\n#| error: false\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"cdr-book/CDR\")\n```\n\n---\n\nConcretamente, se representa la distribución de la renta neta per cápita (`renta_municipio_data`) por municipio (`municipios`) en España en el año 2019.\n\nEl primer paso será integrar los ficheros `renta_municipio-data` y `municipios`, los cuales deben tener un campo en común (`codigo_ine`), para unir. \n\n```{r}\n#| label: crear-rentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta <- municipios |>\n  left_join(renta_municipio_data) |>\n  select(name, cpro, cmun, `2019`)    \n```\n\nEl siguiente paso es la representación gráfica de estos datos en el mapa.\n\n```{r}\n#| label: printarrentaxmunicipio\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\ngrafico <- ggplot(munis_renta) +\n  geom_sf(aes(fill = `2019`), color = NA) +\n  scale_fill_continuous(\n    labels = scales::label_number(\n      big.mark = \".\", decimal.mark = \",\", suffix = \" €\" )) +\n  theme_minimal()\nprint(grafico)\n```\n\n---\n\nPodemos ver que es un **mapa temático de coropletas**. Un gráfico de coropletas es una visualización sencilla de cómo varía la distribunción de una variable. \n\nSi visualizamos el contenido del objeto `munis_renta` pueden verse una serie de elementos gráficos característicos de los objetos espaciales:\n\n```{r}\n#| label: visualizar-raster-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nhead(munis_renta)[1:3, ]\n```\n\n  - Los datos son de tipo vector\n  - El tipo de geometría es MULTIPOLYGON\n  - El CRS es ETRS89 \n  - Leyenda explica el significado de la variable.\n\n## Atención !!! Cuidado cómo se miente en los mapas\n\nA veces, cuando se crea un mapa de coropletas la información puede aparecer distorsionada. \n\nPor ello, para la correcta visualización de los datos que favorezca una interpretación realista es necesario tomar una serie de decisiones:\n\n1. El número de intervalos (cortes o límites de intervalos) en caso de distribución por intervalos.\n\n2. La escala de color a utilizar.\n\n3. El tratamiento de los valores perdidos.\n\n---\n\nLos mapas de coropletas muestran la distribución espacial de una variable cuyos valores se dividen en clases o intervalos a los cuales se les aplica un esquema de colores, también llamado **paleta**, dónde a cada clase le corresponde un color de la paleta. \n\nExisten muchas formas para agrupar los valores de una variable en clases pero el **método de Fisher-Jenks** es el más popular en los mapas temáticos y en especial, en los de coropletas.\n\n::::{.fragment}\n::: {.callout-tip title=\"R packages\"}\nEl método de agrupación de datos de **Fisher-Jenks** utiliza un algoritmo no lineal para agrupar observaciones de modo que se **maximice la homogeneidad dentro del grupo** y la **heterogeneidad entre los mismos**. \n\nEste algoritmo está desarrollado específicamente para la clasificación de datos espaciales y su visualización en mapas.\n:::\n::::\n\n---\n\nA continuación, vamos a realizar el mapa de la renta neta per cápita en España, a escala municipal, en 2019 con los intervalos realizados con **Fisher-Jenks**\n\n```{r}\n#| label: bbdd-filtrado-renta-R\n#| echo: false\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\nmunis_renta_clean <- munis_renta |>\n  filter(!is.na(`2019`))\n```\n\n\n```{r}\n#| label: cortes-Fisher-Jenks-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n\n# crea Fisher-Jenks clases\nfisher <- classIntervals(munis_renta_clean$`2019`, style = \"fisher\", n = 10)\n```\n\n\n```{r}\n#| label: mapa-renta-FJ-R\n#| echo: true\n#| eval: true\n#| warning: false\n#| message: false\n#| error: false\n#| fig-align: center\n\nggplot(munis_renta_clean) +\n  geom_sf(aes(fill = cut(`2019`, fisher$brks)), color = NA) +\n            scale_fill_viridis_d(option= \"A\" , \n                                 labels= scales::label_number(suffix= \"€\")) +\nguides(fill = guide_colorsteps()) +\n  labs(fill= \"Fisher-Jenks\") +\ntheme_minimal()\n```\n\n## Mapas espaciotemporales\n\n## Mapas animados\n\n## Mapas interactivos\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","incremental":true,"css":["../../../logo.css"],"output-file":"geodescriptiva.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.37","auto-stretch":true,"title":"Geodescriptiva","subtitle":"2024 - 2025","title-slide-attributes":{"data-background-image":"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToarIkwdutv5YPT_-6EgdYP-LV63oltlKcFQ&s","data-background-size":"contain","data-background-opacity":"0.25","data-background-color":"white"},"author":"Conti, D; Ramirez, S","editor":"visual","theme":["night","../../../ideai.scss"],"backgroundTransition":"slide","logo":"../../../imagenes/Logo_UPC.svg.png","footer":"Preprocessing i Models Avançats d'Anàlisis de Dades (PMAAD)","controlsTutorial":true,"scale":0.9,"chalkboard":true,"transition":"fade","transitionSpeed":"slow","code-block-height":"650px"}}},"projectFormats":["html"]}