fichero <- "10022307.DAT"
mesaElectoralVotos <- read.delim(paste0(path, fichero), header = F)
# 3. Preprocessing datos -------------------------------------------------------
## "03" : Candidatura ..........................................................
columnas <- c("tipo", "anyo", "mes", "codigo", "siglas", "denominacion", "codigoCandidaturaPROV",
"codigoCandidaturaCCAA", "CodigoCandidaturaNAC")
longitud <- c(2, 4, 2, 6, 50, 150, 6, 6, 6)
candidaturas$V1 <- iconv(candidaturas$V1, from = "latin1", to = "UTF-8")
candidaturas <- data.frame(t(sapply(candidaturas$V1, separar_cadena, longitudes = longitud)))
colnames(candidaturas) <- columnas; rownames(candidaturas) <- NULL
### Moficamos las variables según su tipo
candidaturas <- candidaturas[, c("codigo", "siglas")]
## "09" : Mesa electoral .......................................................
columnas <- c("tipo", "anyo", "mes", "vuelta", "CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "Censo", "Escrutinio", "ResidentesExtrangeros", "TotalVotantes",
"Participacion1", "Participacion2", "votosBlanco", "votosNulos",
"votosAfirmativos", "votosNegativos", "datosOficiales")
longitud <- c(2, 4, 2, 1, 2, 2, 3, 2, 4, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1)
mesaElectoral$V1 <- iconv(mesaElectoral$V1, from = "latin1", to = "UTF-8")
mesaElectoral <- data.frame(t(sapply(mesaElectoral$V1, separar_cadena, longitudes = longitud)))
colnames(mesaElectoral) <- columnas; rownames(mesaElectoral) <- NULL
### Moficamos las variables según su tipo
mesaElectoral <- mesaElectoral[, c("CCAA", "PROV", "MUN", "DIS", "SSCC", "Mesa",
"Censo", "Escrutinio", "ResidentesExtrangeros",
"Participacion1", "Participacion2", "votosBlanco",
"votosNulos", "votosAfirmativos")]
mesaElectoral$id <- paste0(mesaElectoral$PROV, mesaElectoral$MUN, mesaElectoral$DIS,
mesaElectoral$SSCC, mesaElectoral$Mesa)
## "10" : Mesa electoral Votos .................................................
columnas <- c("tipo", "anyo", "mes", "vuelta", "CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "codCandidatura", "votos")
longitud <- c(2, 4, 2, 1, 2, 2, 3, 2, 4, 1, 6, 7)
mesaElectoralVotos$V1 <- iconv(mesaElectoralVotos$V1, from = "latin1", to = "UTF-8")
mesaElectoralVotos <- data.frame(t(sapply(mesaElectoralVotos$V1, separar_cadena, longitudes = longitud)))
colnames(mesaElectoralVotos) <- columnas; rownames(mesaElectoralVotos) <- NULL
mesaElectoralVotos <- mesaElectoralVotos[, c("CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "codCandidatura", "votos")]
mesaElectoralVotos$id <- paste0(mesaElectoralVotos$PROV, mesaElectoralVotos$MUN, mesaElectoralVotos$DIS,
mesaElectoralVotos$SSCC, mesaElectoralVotos$Mesa)
mesaElectoralVotos$votos <- as.numeric(as.character(mesaElectoralVotos$votos))
# 4.  Data manipulation --------------------------------------------------------
## Unimos partidos a votos
m <- match(mesaElectoralVotos$codCandidatura, candidaturas$codigo)
mesaElectoralVotos[, "siglas"] <- stringr::str_trim(candidaturas[m, "siglas"])
## Creamos el cast de la base de datos
library(tidyr)
library(dplyr)
tablaElectoral <- mesaElectoralVotos %>%
dplyr::filter(CCAA == "09") %>%
select(-Mesa, -codCandidatura) %>%
tidyr::pivot_wider(names_from = siglas,
values_from = votos,
values_fill = 0)
rm(candidaturas, mesaElectoralVotos, columnas, fichero, longitud, m, partidos, separar_cadena);gc()
m <- match(tablaElectoral$id, mesaElectoral$id)
vars <- c("Censo", "Escrutinio", "ResidentesExtrangeros",
"Participacion1", "Participacion2", "votosBlanco",
"votosNulos")
tablaElectoral[, vars] <- mesaElectoral[m, vars]
tablaElectoral <- data.frame(tablaElectoral)
for (v in vars) {
tablaElectoral[, v] <- as.numeric(tablaElectoral[, v])
}
rm(mesaElectoral, m, v, vars)
# 5.  Creamos nuevas variables -------------------------------------------------
## VotosAceptados
partidos <- c("FO", "VOX", "RECORTES.CERO", "PSC", "PP", "ERC", "SUMAR...ECP", "CUP.PR", "PCTC", "PDeCAT.E.CiU",
"JxCAT...JUNTS", "PACMA", "ESCONS.EN.BLANC", "EVC", "UNIDOS.SI"  )
tablaElectoral$votosTotales <- rowSums(tablaElectoral[, c(partidos, "votosNulos", "votosBlanco")])
head(tablaElectoral)
tablaElectoral$SSCC <- paste0(tablaElectoral$PROV, tablaElectoral$MUN, tablaElectoral$DIS,
tablaElectoral$SSCC)
tablaElectoral$SSCC
head(tablaElectoral)
df_sumado <- tablaElectoral %>%
select(-id) %>%
group_by(CCAA, PROV, MUN, DIS, SSCC) %>%
summarise(across(where(is.numeric), sum, na.rm = TRUE))
View(df_sumado)
df_sumado <- tablaElectoral %>%
select(-id) %>%
group_by(CCAA, PROV, MUN, DIS, SSCC) %>%
summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE)))
df_sumado <- tablaElectoral %>%
select(-id) %>%
group_by(CCAA, PROV, MUN, DIS, SSCC) %>%
summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE)), .groups = 'drop')
View(df_sumado)
tablaElectoral <- tablaElectoral %>%
select(-id) %>%
group_by(CCAA, PROV, MUN, DIS, SSCC) %>%
summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE)), .groups = 'drop')
tablaElectoral$partManyana <- tablaElectoral$Participacion1/tablaElectoral$Censo
tablaElectoral$partTarde <- tablaElectoral$Participacion2/tablaElectoral$Censo
tablaElectoral$partFinal <- tablaElectoral$votosTotales/tablaElectoral$Censo
tablaElectoral[, c("Participacion1", "Participacion2", "Escrutinio", "ResidentesExtrangeros")] <- NULL
View(tablaElectoral)
colnames(tablaElectoral)
tablaElectoral[, p] <- tablaElectoral[, p]/tablaElectoral[, "votosTotales"]
for (p in partidos) {
tablaElectoral[, p] <- tablaElectoral[, p]/tablaElectoral[, "votosTotales"]
}
for (p in c(partidos, "votosBlanco", "votosNulos")) {
tablaElectoral[, p] <- tablaElectoral[, p]/tablaElectoral[, "votosTotales"]
}
# 1. Cargar librerias ----------------------------------------------------------
library(sf)
library(stringr)
library(reshape2)
# Función para separar las cadenas de texto
separar_cadena <- function(cadena, longitudes) {
# Comienza desde el índice 1
inicio <- 1
partes <- c()  # Vector para almacenar las partes
for (long in longitudes) {
# Extrae la subcadena según la longitud
partes <- c(partes, substr(cadena, inicio, inicio + long - 1))
# Actualiza el índice de inicio para la siguiente subcadena
inicio <- inicio + long
}
return(partes)
}
# 2. Cargar datos --------------------------------------------------------------
# 2.1 Acceso a la web ..........................................................
# Accedemos a la web: https://infoelectoral.interior.gob.es/es/elecciones-celebradas/area-de-descargas/
# Seleccionamos: Convocatoria -> Congreso
#                Fecha -> Julio 2023
# Damos en el botón de Consultar y descargamos los datos a nivel de Mesa. Se descargarà
# un .zip
# 2.2 Acceder a los datos ......................................................
## "03" : Candidatura
path <- "C:/Users/sergi/Downloads/02202307_MESA/"
fichero <- "03022307.DAT"
candidaturas <- read.delim(paste0(path, fichero), header = F)
## "09" : Mesa electoral
fichero <- "09022307.DAT"
mesaElectoral <- read.delim(paste0(path, fichero), header = F)
## "10" : Mesa electoral votos
fichero <- "10022307.DAT"
mesaElectoralVotos <- read.delim(paste0(path, fichero), header = F)
# 3. Preprocessing datos -------------------------------------------------------
## "03" : Candidatura ..........................................................
columnas <- c("tipo", "anyo", "mes", "codigo", "siglas", "denominacion", "codigoCandidaturaPROV",
"codigoCandidaturaCCAA", "CodigoCandidaturaNAC")
longitud <- c(2, 4, 2, 6, 50, 150, 6, 6, 6)
candidaturas$V1 <- iconv(candidaturas$V1, from = "latin1", to = "UTF-8")
candidaturas <- data.frame(t(sapply(candidaturas$V1, separar_cadena, longitudes = longitud)))
colnames(candidaturas) <- columnas; rownames(candidaturas) <- NULL
### Moficamos las variables según su tipo
candidaturas <- candidaturas[, c("codigo", "siglas")]
## "09" : Mesa electoral .......................................................
columnas <- c("tipo", "anyo", "mes", "vuelta", "CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "Censo", "Escrutinio", "ResidentesExtrangeros", "TotalVotantes",
"Participacion1", "Participacion2", "votosBlanco", "votosNulos",
"votosAfirmativos", "votosNegativos", "datosOficiales")
longitud <- c(2, 4, 2, 1, 2, 2, 3, 2, 4, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1)
mesaElectoral$V1 <- iconv(mesaElectoral$V1, from = "latin1", to = "UTF-8")
mesaElectoral <- data.frame(t(sapply(mesaElectoral$V1, separar_cadena, longitudes = longitud)))
colnames(mesaElectoral) <- columnas; rownames(mesaElectoral) <- NULL
### Moficamos las variables según su tipo
mesaElectoral <- mesaElectoral[, c("CCAA", "PROV", "MUN", "DIS", "SSCC", "Mesa",
"Censo", "Escrutinio", "ResidentesExtrangeros",
"Participacion1", "Participacion2", "votosBlanco",
"votosNulos", "votosAfirmativos")]
mesaElectoral$id <- paste0(mesaElectoral$PROV, mesaElectoral$MUN, mesaElectoral$DIS,
mesaElectoral$SSCC, mesaElectoral$Mesa)
## "10" : Mesa electoral Votos .................................................
columnas <- c("tipo", "anyo", "mes", "vuelta", "CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "codCandidatura", "votos")
longitud <- c(2, 4, 2, 1, 2, 2, 3, 2, 4, 1, 6, 7)
mesaElectoralVotos$V1 <- iconv(mesaElectoralVotos$V1, from = "latin1", to = "UTF-8")
mesaElectoralVotos <- data.frame(t(sapply(mesaElectoralVotos$V1, separar_cadena, longitudes = longitud)))
colnames(mesaElectoralVotos) <- columnas; rownames(mesaElectoralVotos) <- NULL
mesaElectoralVotos <- mesaElectoralVotos[, c("CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "codCandidatura", "votos")]
mesaElectoralVotos$id <- paste0(mesaElectoralVotos$PROV, mesaElectoralVotos$MUN, mesaElectoralVotos$DIS,
mesaElectoralVotos$SSCC, mesaElectoralVotos$Mesa)
mesaElectoralVotos$votos <- as.numeric(as.character(mesaElectoralVotos$votos))
# 4.  Data manipulation --------------------------------------------------------
## Unimos partidos a votos
m <- match(mesaElectoralVotos$codCandidatura, candidaturas$codigo)
mesaElectoralVotos[, "siglas"] <- stringr::str_trim(candidaturas[m, "siglas"])
## Creamos el cast de la base de datos
library(tidyr)
library(dplyr)
tablaElectoral <- mesaElectoralVotos %>%
dplyr::filter(CCAA == "09") %>%
select(-Mesa, -codCandidatura) %>%
tidyr::pivot_wider(names_from = siglas,
values_from = votos,
values_fill = 0)
rm(candidaturas, mesaElectoralVotos, columnas, fichero, longitud, m, partidos, separar_cadena);gc()
m <- match(tablaElectoral$id, mesaElectoral$id)
vars <- c("Censo", "Escrutinio", "ResidentesExtrangeros",
"Participacion1", "Participacion2", "votosBlanco",
"votosNulos")
tablaElectoral[, vars] <- mesaElectoral[m, vars]
tablaElectoral <- data.frame(tablaElectoral)
for (v in vars) {
tablaElectoral[, v] <- as.numeric(tablaElectoral[, v])
}
rm(mesaElectoral, m, v, vars)
# 5.  Creamos nuevas variables -------------------------------------------------
## VotosAceptados
partidos <- c("FO", "VOX", "RECORTES.CERO", "PSC", "PP", "ERC", "SUMAR...ECP", "CUP.PR", "PCTC", "PDeCAT.E.CiU",
"JxCAT...JUNTS", "PACMA", "ESCONS.EN.BLANC", "EVC", "UNIDOS.SI"  )
tablaElectoral$votosTotales <- rowSums(tablaElectoral[, c(partidos, "votosNulos", "votosBlanco")])
tablaElectoral$SSCC <- paste0(tablaElectoral$PROV, tablaElectoral$MUN, tablaElectoral$DIS,
tablaElectoral$SSCC)
tablaElectoral <- tablaElectoral %>%
select(-id) %>%
group_by(CCAA, PROV, MUN, DIS, SSCC) %>%
summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE)), .groups = 'drop')
tablaElectoral$partManyana <- tablaElectoral$Participacion1/tablaElectoral$Censo
tablaElectoral$partTarde <- tablaElectoral$Participacion2/tablaElectoral$Censo
tablaElectoral$partFinal <- tablaElectoral$votosTotales/tablaElectoral$Censo
tablaElectoral[, c("Participacion1", "Participacion2", "Escrutinio", "ResidentesExtrangeros")] <- NULL
for (p in c(partidos, "votosBlanco", "votosNulos")) {
tablaElectoral[, p] <- tablaElectoral[, p]/tablaElectoral[, "votosTotales"]
}
View(tablaElectoral)
colnames(tablaElectoral)
# 6.  --------------------------------------------------------------------------
vars <- c(partidos, "votosBlanco", "votosNulos")
# 6. Clustering ----------------------------------------------------------------
vars <- c(partidos, "votosBlanco", "votosNulos")
distancias <- dist(tablaElectoral[, vars], method = "euclidian")
clusters <- hclust(distancias, method = "ward.D2")
plot(clusters)
tablaElectoral$cluster <- cutree(clusters, k = 3)
head(tablaElectoral)
library(factoext)
library(factoextra)
library(FactoMineR)
plot(catdes(tablaElectoral, num.var = 28))
tablaElectoral$cluster <- as.character(cutree(clusters, k = 3))
plot(catdes(tablaElectoral, num.var = 28))
plot(catdes(tablaElectoral[, c(vars, "cluster")], num.var = 28))
oo <- tablaElectoral[, c(vars, "cluster")]
plot(catdes(tablaElectoral[, c(vars, "cluster")], num.var = 18))
plot(catdes(tablaElectoral[, c(vars, "cluster")], num.var = 18), cex.names = 1.5)
# 7.  Visualización ------------------------------------------------------------
tablaElectoral <- data.frame(tablaElectoral)
head(tablaElectoral)
library(sf)        # Para leer shapefiles/geojson
library(leaflet)   # Para el mapa
library(dplyr)     # Para manipular datos
library(RColorBrewer)  # Paletas de colores
# Cargamos los mapas
sscc_shape <- st_read("C:/Users/sergi/Downloads/seccionado_2024/SECC_CE_20240101.shp")  # o .shp
sscc_shape <- sscc_shape %>%
left_join(tablaElectoral, by = c("CUSEC" = "SSCC"))  # Asegúrate que los nombres coincidan
pal <- colorFactor(brewer.pal(length(unique(tablaElectoral$cluster)), "Set1"), tablaElectoral$cluster)
pal
# Generar popups con porcentajes
sscc_shape$popup <- paste0(
"<strong>SSCC: </strong>", sscc_shape$SSCC, "<br/>",
"<strong>Cluster: </strong>", sscc_shape$cluster, "<br/>",
"<strong>PSC: </strong>", round(sscc_shape$PSC * 100, 2), "%<br/>",
"<strong>PP: </strong>", round(sscc_shape$PP * 100, 2), "%<br/>",
"<strong>ERC: </strong>", round(sscc_shape$ERC * 100, 2), "%<br/>",
"<strong>VOX: </strong>", round(sscc_shape$VOX * 100, 2), "%<br/>"
# Añade más líneas si quieres incluir más partidos
)
sscc_shape$popup
leaflet(sscc_shape) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
fillColor = ~pal(cluster),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~popup
) %>%
addLegend("bottomright", pal = pal, values = ~cluster,
title = "Cluster", opacity = 1)
sscc_shape <- sscc_shape[sscc_shape$CPRO == "09"]
sscc_shape$CPRO
sscc_shape$CPRO == "09"
sscc_shape[sscc_shape$CPRO == "09"]
sscc_shape <- sscc_shape[sscc_shape$CPRO == "09", ]
plot(sscc_shape)
# Cargamos los mapas
sscc_shape <- st_read("C:/Users/sergi/Downloads/seccionado_2024/SECC_CE_20240101.shp")  # o .shp
sscc_shape <- sscc_shape[sscc_shape$CPRO == "08", ]
plot(sscc_shape)
sscc_shape <- sscc_shape[sscc_shape$CCA == "09", ]
# Cargamos los mapas
sscc_shape <- st_read("C:/Users/sergi/Downloads/seccionado_2024/SECC_CE_20240101.shp")  # o .shp
sscc_shape <- sscc_shape[sscc_shape$CCA == "09", ]
plot(sscc_shape)
sscc_shape <- sscc_shape %>%
left_join(tablaElectoral, by = c("CUSEC" = "SSCC"))  # Asegúrate que los nombres coincidan
pal <- colorFactor(brewer.pal(length(unique(tablaElectoral$cluster)), "Set1"), tablaElectoral$cluster)
# Generar popups con porcentajes
sscc_shape$popup <- paste0(
"<strong>SSCC: </strong>", sscc_shape$SSCC, "<br/>",
"<strong>Cluster: </strong>", sscc_shape$cluster, "<br/>",
"<strong>PSC: </strong>", round(sscc_shape$PSC * 100, 2), "%<br/>",
"<strong>PP: </strong>", round(sscc_shape$PP * 100, 2), "%<br/>",
"<strong>ERC: </strong>", round(sscc_shape$ERC * 100, 2), "%<br/>",
"<strong>VOX: </strong>", round(sscc_shape$VOX * 100, 2), "%<br/>"
# Añade más líneas si quieres incluir más partidos
)
# Crear el mapa
leaflet(sscc_shape) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
fillColor = ~pal(cluster),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~popup
) %>%
addLegend("bottomright", pal = pal, values = ~cluster,
title = "Cluster", opacity = 1)
sscc_shape$cluster
head(sscc_shape)
sscc_shape <- sscc_shape %>%
left_join(tablaElectoral, by = c("SSCC" = "CUSEC"))  # Asegúrate que los nombres coincidan
sscc_shape <- sscc_shape %>%
left_join(tablaElectoral, by = c("CUSEC" = "SSCC"))  # Asegúrate que los nombres coincidan
sscc_shape
# Cargamos los mapas
sscc_shape <- st_read("C:/Users/sergi/Downloads/seccionado_2024/SECC_CE_20240101.shp")  # o .shp
sscc_shape <- sscc_shape[sscc_shape$CCA == "09", ]
sscc_shape <- sscc_shape %>%
left_join(tablaElectoral, by = c("CUSEC" = "SSCC"))  # Asegúrate que los nombres coincidan
sscc_shape
head(tablaElectoral)
str(sscc_shape)
m <- match(sscc_shape$CUSEC, tablaElectoral$SSCC)
m
summary(m)
min(sscc_shape$CSEC)
min(sscc_shape$CUSEC)
min(tablaElectoral$SSCC)
tablaElectoral$SSCC <- stringr::str_trim(paste0(tablaElectoral$PROV, tablaElectoral$MUN, tablaElectoral$DIS,
tablaElectoral$SSCC))
min(tablaElectoral$SSCC)
# 1. Cargar librerias ----------------------------------------------------------
library(sf)
library(stringr)
library(reshape2)
library(FactoMineR)
# Función para separar las cadenas de texto
separar_cadena <- function(cadena, longitudes) {
# Comienza desde el índice 1
inicio <- 1
partes <- c()  # Vector para almacenar las partes
for (long in longitudes) {
# Extrae la subcadena según la longitud
partes <- c(partes, substr(cadena, inicio, inicio + long - 1))
# Actualiza el índice de inicio para la siguiente subcadena
inicio <- inicio + long
}
return(partes)
}
# 2. Cargar datos --------------------------------------------------------------
# 2.1 Acceso a la web ..........................................................
# Accedemos a la web: https://infoelectoral.interior.gob.es/es/elecciones-celebradas/area-de-descargas/
# Seleccionamos: Convocatoria -> Congreso
#                Fecha -> Julio 2023
# Damos en el botón de Consultar y descargamos los datos a nivel de Mesa. Se descargarà
# un .zip
# 2.2 Acceder a los datos ......................................................
## "03" : Candidatura
path <- "C:/Users/sergi/Downloads/02202307_MESA/"
fichero <- "03022307.DAT"
candidaturas <- read.delim(paste0(path, fichero), header = F)
## "09" : Mesa electoral
fichero <- "09022307.DAT"
mesaElectoral <- read.delim(paste0(path, fichero), header = F)
## "10" : Mesa electoral votos
fichero <- "10022307.DAT"
mesaElectoralVotos <- read.delim(paste0(path, fichero), header = F)
# 3. Preprocessing datos -------------------------------------------------------
## "03" : Candidatura ..........................................................
columnas <- c("tipo", "anyo", "mes", "codigo", "siglas", "denominacion", "codigoCandidaturaPROV",
"codigoCandidaturaCCAA", "CodigoCandidaturaNAC")
longitud <- c(2, 4, 2, 6, 50, 150, 6, 6, 6)
candidaturas$V1 <- iconv(candidaturas$V1, from = "latin1", to = "UTF-8")
candidaturas <- data.frame(t(sapply(candidaturas$V1, separar_cadena, longitudes = longitud)))
colnames(candidaturas) <- columnas; rownames(candidaturas) <- NULL
### Moficamos las variables según su tipo
candidaturas <- candidaturas[, c("codigo", "siglas")]
## "09" : Mesa electoral .......................................................
columnas <- c("tipo", "anyo", "mes", "vuelta", "CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "Censo", "Escrutinio", "ResidentesExtrangeros", "TotalVotantes",
"Participacion1", "Participacion2", "votosBlanco", "votosNulos",
"votosAfirmativos", "votosNegativos", "datosOficiales")
longitud <- c(2, 4, 2, 1, 2, 2, 3, 2, 4, 1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1)
mesaElectoral$V1 <- iconv(mesaElectoral$V1, from = "latin1", to = "UTF-8")
mesaElectoral <- data.frame(t(sapply(mesaElectoral$V1, separar_cadena, longitudes = longitud)))
colnames(mesaElectoral) <- columnas; rownames(mesaElectoral) <- NULL
### Moficamos las variables según su tipo
mesaElectoral <- mesaElectoral[, c("CCAA", "PROV", "MUN", "DIS", "SSCC", "Mesa",
"Censo", "Escrutinio", "ResidentesExtrangeros",
"Participacion1", "Participacion2", "votosBlanco",
"votosNulos", "votosAfirmativos")]
mesaElectoral$id <- paste0(mesaElectoral$PROV, mesaElectoral$MUN, mesaElectoral$DIS,
mesaElectoral$SSCC, mesaElectoral$Mesa)
## "10" : Mesa electoral Votos .................................................
columnas <- c("tipo", "anyo", "mes", "vuelta", "CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "codCandidatura", "votos")
longitud <- c(2, 4, 2, 1, 2, 2, 3, 2, 4, 1, 6, 7)
mesaElectoralVotos$V1 <- iconv(mesaElectoralVotos$V1, from = "latin1", to = "UTF-8")
mesaElectoralVotos <- data.frame(t(sapply(mesaElectoralVotos$V1, separar_cadena, longitudes = longitud)))
colnames(mesaElectoralVotos) <- columnas; rownames(mesaElectoralVotos) <- NULL
mesaElectoralVotos <- mesaElectoralVotos[, c("CCAA", "PROV", "MUN", "DIS", "SSCC",
"Mesa", "codCandidatura", "votos")]
mesaElectoralVotos$id <- paste0(mesaElectoralVotos$PROV, mesaElectoralVotos$MUN, mesaElectoralVotos$DIS,
mesaElectoralVotos$SSCC, mesaElectoralVotos$Mesa)
mesaElectoralVotos$votos <- as.numeric(as.character(mesaElectoralVotos$votos))
# 4.  Data manipulation --------------------------------------------------------
## Unimos partidos a votos
m <- match(mesaElectoralVotos$codCandidatura, candidaturas$codigo)
mesaElectoralVotos[, "siglas"] <- stringr::str_trim(candidaturas[m, "siglas"])
## Creamos el cast de la base de datos
library(tidyr)
library(dplyr)
tablaElectoral <- mesaElectoralVotos %>%
dplyr::filter(CCAA == "09") %>%
select(-Mesa, -codCandidatura) %>%
tidyr::pivot_wider(names_from = siglas,
values_from = votos,
values_fill = 0)
rm(candidaturas, mesaElectoralVotos, columnas, fichero, longitud, m, partidos, separar_cadena);gc()
m <- match(tablaElectoral$id, mesaElectoral$id)
vars <- c("Censo", "Escrutinio", "ResidentesExtrangeros",
"Participacion1", "Participacion2", "votosBlanco",
"votosNulos")
tablaElectoral[, vars] <- mesaElectoral[m, vars]
tablaElectoral <- data.frame(tablaElectoral)
for (v in vars) {
tablaElectoral[, v] <- as.numeric(tablaElectoral[, v])
}
rm(mesaElectoral, m, v, vars)
# 5.  Creamos nuevas variables -------------------------------------------------
## VotosAceptados
partidos <- c("FO", "VOX", "RECORTES.CERO", "PSC", "PP", "ERC", "SUMAR...ECP", "CUP.PR", "PCTC", "PDeCAT.E.CiU",
"JxCAT...JUNTS", "PACMA", "ESCONS.EN.BLANC", "EVC", "UNIDOS.SI"  )
tablaElectoral$votosTotales <- rowSums(tablaElectoral[, c(partidos, "votosNulos", "votosBlanco")])
tablaElectoral$SSCC <- stringr::str_trim(paste0(tablaElectoral$PROV, tablaElectoral$MUN, tablaElectoral$DIS,
tablaElectoral$SSCC))
tablaElectoral <- tablaElectoral %>%
select(-id) %>%
group_by(CCAA, PROV, MUN, DIS, SSCC) %>%
summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE)), .groups = 'drop')
tablaElectoral$partManyana <- tablaElectoral$Participacion1/tablaElectoral$Censo
tablaElectoral$partTarde <- tablaElectoral$Participacion2/tablaElectoral$Censo
tablaElectoral$partFinal <- tablaElectoral$votosTotales/tablaElectoral$Censo
tablaElectoral[, c("Participacion1", "Participacion2", "Escrutinio", "ResidentesExtrangeros")] <- NULL
for (p in c(partidos, "votosBlanco", "votosNulos")) {
tablaElectoral[, p] <- tablaElectoral[, p]/tablaElectoral[, "votosTotales"]
}
# 6. Clustering ----------------------------------------------------------------
vars <- c(partidos, "votosBlanco", "votosNulos")
distancias <- dist(tablaElectoral[, vars], method = "euclidian")
clusters <- hclust(distancias, method = "ward.D2")
tablaElectoral$cluster <- as.character(cutree(clusters, k = 3))
plot(catdes(tablaElectoral[, c(vars, "cluster")], num.var = 18), cex.names = 1.5)
# 7.  Visualización ------------------------------------------------------------
tablaElectoral <- data.frame(tablaElectoral)
library(sf)        # Para leer shapefiles/geojson
library(leaflet)   # Para el mapa
library(dplyr)     # Para manipular datos
library(RColorBrewer)  # Paletas de colores
# Cargamos los mapas
sscc_shape <- st_read("C:/Users/sergi/Downloads/seccionado_2024/SECC_CE_20240101.shp")  # o .shp
sscc_shape <- sscc_shape[sscc_shape$CCA == "09", ]
sscc_shape <- sscc_shape %>%
left_join(tablaElectoral, by = c("CUSEC" = "SSCC"))  # Asegúrate que los nombres coincidan
pal <- colorFactor(brewer.pal(length(unique(tablaElectoral$cluster)), "Set1"), tablaElectoral$cluster)
pal
sscc_shape
# Generar popups con porcentajes
sscc_shape$popup <- paste0(
"<strong>SSCC: </strong>", sscc_shape$SSCC, "<br/>",
"<strong>Cluster: </strong>", sscc_shape$cluster, "<br/>",
"<strong>PSC: </strong>", round(sscc_shape$PSC * 100, 2), "%<br/>",
"<strong>PP: </strong>", round(sscc_shape$PP * 100, 2), "%<br/>",
"<strong>ERC: </strong>", round(sscc_shape$ERC * 100, 2), "%<br/>",
"<strong>VOX: </strong>", round(sscc_shape$VOX * 100, 2), "%<br/>"
# Añade más líneas si quieres incluir más partidos
)
# Crear el mapa
leaflet(sscc_shape) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
fillColor = ~pal(cluster),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~popup
) %>%
addLegend("bottomright", pal = pal, values = ~cluster,
title = "Cluster", opacity = 1)
# Reproyectar la capa a WGS84 (long-lat)
sscc_shape <- st_transform(sscc_shape, crs = 4326)
# Crear el mapa
leaflet(sscc_shape) %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(
fillColor = ~pal(cluster),
fillOpacity = 0.7,
color = "white",
weight = 1,
popup = ~popup
) %>%
addLegend("bottomright", pal = pal, values = ~cluster,
title = "Cluster", opacity = 1)
