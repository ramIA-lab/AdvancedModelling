quit
#| label: geo-BCN-R
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: margin
p <- ggplot(data = BCN,
aes(x = LONGITUDE, y = LATITUDE)) +
geom_point(col="blue", size = 0.1, alpha = 0.3) +
coord_fixed()
#| label: geo-BCN-R-plot1
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: margin
print(p)
reticulate::repl_python()
#| label: geo-BCN-Py
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
from plotnine import ggplot, aes, geom_point, coord_fixed, theme_minimal
from plotnine import ggtitle, xlab, ylab
p = (ggplot(pyBCN, aes(x='LONGITUDE', y='LATITUDE')) +
geom_point(color='blue', size=0.1, alpha=0.3) +
coord_fixed() +
theme_minimal() +
ggtitle("Pisos en Barcelona") +
xlab("Longitud") +
ylab("Latitud"))
#| label: geo-BCN-Py-plot1
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
p.show()
quit
#| label: geo-BCN-R-cambiarCRS
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
library(sf)
idealista2018_sf <- sf::st_as_sf(BCN,
coords = c("LATITUDE", "LONGITUDE"),
crs = 25830) # proyección ETRS89/ UTM zone 30N. Área de uso: Europa
#| label: geo-BCN-R
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
library(mapSpain)
Barcelona <- mapSpain::esp_get_munic(munic = "^Barcelona$") |>
sf::st_transform(25830)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 2)
#| label: geo-BCN-R
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: margin
library(tidyterra)
grafico <- ggplot() +
tidyterra::geom_spatraster_rgb(data = tile) +
geom_sf(data = idealista2018_sf,
col = "blue", size = 0.1, alpha = 0.3) +
coord_sf(expand = FALSE)
#| label: geo-BCN-R-plot1
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: margin
plot(grafico)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 3)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 11)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 8)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 3)
library(mapSpain)
Barcelona <- mapSpain::esp_get_munic(munic = "^Barcelona$") |>
sf::st_transform(25830)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 3, verbose = FALSE)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 3, verbose = TRUE)
install.packages("maptiles")
?get_tiles
#| label: librerias-R
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
library("idealista18")
library(ggplot2)
library(sf)
library(maptiles)
library(mapSpain)
library(tidyterra)
reticulate::repl_python()
#| label: librerias-Py
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
from plotnine import ggplot, aes, geom_point, coord_fixed, theme_minimal
from plotnine import ggtitle, xlab, ylab
import geopandas as gpd
import matplotlib.pyplot as plt
import contextily as ctx
from shapely.geometry import Point
quit
#| label: bbdd-ejemplo-R
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
BCN <- get(data("Barcelona_Sale"))
# Filtramos la epoca a Navidad
BCN <- BCN[which(BCN$PERIOD == "201812"), ]
sf::st_geometry(BCN) <- "geometry"
reticulate::repl_python()
#| label: bbdd-ejemplo-Py
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
pyBCN = r.BCN
quit
#| label: geo-BCN-R
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: margin
p <- ggplot(data = BCN,
aes(x = LONGITUDE, y = LATITUDE)) +
geom_point(col="blue", size = 0.1, alpha = 0.3) +
coord_fixed()
#| label: geo-BCN-R-plot1
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: margin
print(p)
reticulate::repl_python()
#| label: geo-BCN-Py
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
p = (ggplot(pyBCN, aes(x='LONGITUDE', y='LATITUDE')) +
geom_point(color='blue', size=0.1, alpha=0.3) +
coord_fixed() +
theme_minimal() +
ggtitle("Pisos en Barcelona") +
xlab("Longitud") +
ylab("Latitud"))
#| label: geo-BCN-Py-plot1
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
p.show()
quit
#| label: geo-BCN-R-cambiarCRS
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
idealista2018_sf <- sf::st_as_sf(BCN,
coords = c("LATITUDE", "LONGITUDE"),
crs = 25830) # proyección ETRS89/ UTM zone 30N. Área de uso: Europa
#| label: geo-BCN-R-descargarMapa
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
Barcelona <- mapSpain::esp_get_munic(munic = "^Barcelona$") |>
sf::st_transform(25830)
# descara imagen de un de mapa estático de las carreteas de Madrid
tile <- maptiles::get_tiles(BCN, provider = "Esri.WorldStreetMap", zoom = 10, crop = TRUE)
# tile <- esp_getTiles(Barcelona, "IGNBase.Gris", zoommin = 3, verbose = FALSE)
#| label: geo-BCN-R-creacionMapa
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: screen-inset-right
ggplot() +
tidyterra::geom_spatraster_rgb(data = tile) +
geom_sf(data = idealista2018_sf,
col = "blue", size = 0.1, alpha = 0.3) +
coord_sf(expand = FALSE)
reticulate::repl_python()
#| label: geo-BCN-py-cambiarCRS
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
# 1. Crear GeoDataFrame desde DataFrame (suponiendo que tienes 'LATITUDE' y 'LONGITUDE')
# Nota: en Python 'LONGITUDE' es x, 'LATITUDE' es y
gdf = gpd.GeoDataFrame(pyBCN, geometry = gpd.points_from_xy(pyBCN['LONGITUDE'], pyBCN['LATITUDE']), crs = "EPSG:4326") # primero en WGS84
# 2. Reproyectar a EPSG:25830
gdf_utm = gdf.to_crs(epsg = 25830)
gdf_utm.total_bounds
#| label: geo-BCN-py-descargarMapa
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
# 3. Definir límites para el mapa base
# bounds = gdf_utm.total_bounds  # xmin, ymin, xmax, ymax
bounds = [205233.4209,5052831.5363,278039.6904,5088948.0321]
#| label: geo-BCN-py-creacionMapa
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: screen-inset-right
# 4. Plot con mapa base (tiles tipo Esri.WorldStreetMap)
fig, ax = plt.subplots(figsize = (8, 8))
# Plot puntos
gdf_utm.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)
# Añadir tiles (contextily necesita CRS compatible, normalmente 3857)
# Convertir a 3857 para el tile
gdf_webmerc = gdf_utm.to_crs(epsg = 3857)
ax = gdf_webmerc.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)
# Añadir fondo tipo Esri (o CartoDB, OSM, etc.)
ctx.add_basemap(ax, source = ctx.providers.Esri.WorldStreetMap)
# Quitar márgenes blancos
ax.set_axis_off()
plt.tight_layout()
plt.show()
#| label: geo-BCN-py-descargarMapa
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
# 3. Definir límites para el mapa base
# bounds = gdf_utm.total_bounds  # xmin, ymin, xmax, ymax
bounds = [905729.8210,4580494.7340,958814.7353,4610801.5327]
#| label: geo-BCN-py-creacionMapa
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
#| column: screen-inset-right
# 4. Plot con mapa base (tiles tipo Esri.WorldStreetMap)
fig, ax = plt.subplots(figsize = (8, 8))
# Plot puntos
gdf_utm.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)
# Añadir tiles (contextily necesita CRS compatible, normalmente 3857)
# Convertir a 3857 para el tile
gdf_webmerc = gdf_utm.to_crs(epsg = 3857)
ax = gdf_webmerc.plot(ax = ax, color = 'blue', markersize = 1, alpha = 0.3)
# Añadir fondo tipo Esri (o CartoDB, OSM, etc.)
ctx.add_basemap(ax, source = ctx.providers.Esri.WorldStreetMap)
# Quitar márgenes blancos
ax.set_axis_off()
plt.tight_layout()
plt.show()
#| label: geo-BCN-py-creacionMapa2
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
#| panel: sidebar
# Quitar márgenes blancos
ax.set_axis_off()
plt.tight_layout()
plt.show()
quit
#| label: librerias-R
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
library(idealista18)
library(ggplot2)
library(sf)
library(maptiles)
library(mapSpain)
library(tidyterra)
library(giscoR)
library("giscoR")
paises <- gisco_get_countries()
puertos <- gisco_get_ports()
puertos <- gisco_get_ports()
paises_robin <- st_transform(paises, st_crs("ESRI:54030")) #Proyección Robinson
plot(st_geometry(paises_robin), main = " ")
plot(st_geometry(puertos), add = TRUE, col="2", pch=20, lwd=2.5)
plot(st_geometry(paises_robin), main = " ")
plot(st_geometry(puertos), add = TRUE, col="2", pch=20, lwd=2.5)
#| label: comprobacion-CRS-R
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
st_crs(puertos) == st_crs(paises_robin)
#| label: puertos-R-Robinson
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
puertos_robin <- st_transform(puertos, st_crs(paises_robin))
plot(st_geometry(paises_robin), main = " ")
plot(st_geometry(puertos_robin), add = TRUE, col = 4, pch = 20)
reticulate::repl_python()
#| label: puertos-python-bbdd
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
pyPuertos = r.puertos
pyPaisesRobin = r.paises_robin
pyPuertos
pyPaisesRobin
#| label: comprobacion-CRS-py
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
# Verificar si los CRS son iguales
pyPuertos.crs == pyPaisesRobin.crs
pyPuertos.crs
pyPaisesRobin.crs
#| label: puertos-python-bbdd
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
from rpy2.robjects import r
import geopandas as gpd
import pandas as pd
from shapely import wkt
# Convertir el objeto sf de R a un GeoDataFrame de Python
pyPuertos = r('sf::st_as_text(r.puertos$geometry)')
pyPuertos = pd.DataFrame({'geometry': pyPuertos})
# Convertir a geometría real
pyPuertos['geometry'] = pyPuertos['geometry'].apply(wkt.loads)
pyPuertos = gpd.GeoDataFrame(pyPuertos, geometry='geometry')
# Convertir el objeto sf de R a un GeoDataFrame de Python
pyPaisesRobin = r('sf::st_as_text(r.puertos$geometry)')
pyPaisesRobin = pd.DataFrame({'geometry': pyPaisesRobin})
# Convertir a geometría real
pyPaisesRobin['geometry'] = pyPaisesRobin['geometry'].apply(wkt.loads)
pyPaisesRobin = gpd.GeoDataFrame(pyPaisesRobin, geometry='geometry')
#| label: comprobacion-CRS-py
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
# Verificar si los CRS son iguales
pyPuertos.crs == pyPaisesRobin.crs
pyPuertos.
pyPuertos
pyPuertos.crs
quit
# Obtener el EPSG de paises_robin desde R
crs_str = r('sf::st_crs(r.paises_robin)$proj4string')[0]  # o usa `$wkt` si quieres más precisión
# Obtener el EPSG de paises_robin desde R
crs_str = r('sf::st_crs(paises_robin)$proj4string')[0]  # o usa `$wkt` si quieres más precisión
reticulate::repl_python()
crs_str = r('sf::st_crs(paises_robin)$proj4string')[0]  # o usa `$wkt` si quieres más precisión
crs_str = r('sf::st_crs(paises_robin)$proj4string')[0]  # o usa `$wkt` si quieres más precisión
crs_str
quit
library(tidyverse)
library(tidyverse)
library(osmdata)
library(ggmap)
#| label: mercadona-R-bbdd
#| echo: false
#| eval: true
#| warning: false
#| message: false
#| error: false
q <- getbb("Barcelona") |>
opq(timeout = 25 * 100) |>
add_osm_feature("name", "Mercadona") |>
add_osm_feature("shop", "supermarket")
# building the query
# query
mercadona <- osmdata_sf(q)
#| label: puertos-R-Robinson
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
ggplot() +
geom_sf(data = mercadona,
aes(fill = "Mercadona"),
color = "lightgreen") +
labs(title = NULL, fill = NULL) +
theme_minimal() +
theme(legend.position = "right")
ggplot() +
geom_sf(data = mercadona$osm_points,
aes(fill = "Mercadona"),
color = "lightgreen") +
labs(title = NULL, fill = NULL) +
theme_minimal() +
theme(legend.position = "right")
library("CDR")
install.packages("CDR")
install.packages("remotes")
remotes::install_github("cdr-book/CDR")
library("CDR")
#| label: cargar-paquete-CDR
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
munis_renta <- municipios |>
left_join(renta_municipio_data) |>
select(name, cpro, cmun, `2019`)
ggplot(munis_renta) +
geom_sf(aes(fill = `2019`), color = NA) +
scale_fill_continuous(
labels = scales::label_number(
big.mark = ".", decimal.mark = ",", suffix = " €" )) +
theme_minimal()
#| label: printar-rentaxmunicipio
#| echo: true
#| eval: true
#| warning: false
#| message: false
#| error: false
gafico <- ggplot(munis_renta) +
geom_sf(aes(fill = `2019`), color = NA) +
scale_fill_continuous(
labels = scales::label_number(
big.mark = ".", decimal.mark = ",", suffix = " €" )) +
theme_minimal()
plot(grafico)
gafico <- ggplot(munis_renta) +
geom_sf(aes(fill = `2019`), color = NA) +
scale_fill_continuous(
labels = scales::label_number(
big.mark = ".", decimal.mark = ",", suffix = " €" )) +
theme_minimal()
plot(grafico)
print(grafico)
ggplot(munis_renta) +
geom_sf(aes(fill = `2019`), color = NA) +
scale_fill_continuous(
labels = scales::label_number(
big.mark = ".", decimal.mark = ",", suffix = " €" )) +
theme_minimal()
grafico <- ggplot(munis_renta) +
geom_sf(aes(fill = `2019`), color = NA) +
scale_fill_continuous(
labels = scales::label_number(
big.mark = ".", decimal.mark = ",", suffix = " €" )) +
theme_minimal()
print(grafico)
library(classInt)
munis_renta_clean <- munis_renta |>
filter(!is.na(`2019`))
# crea Fisher-Jenks clases
fisher <- classIntervals(munis_renta_clean$`2019`, style = "fisher", n = 10)
fisher
ggplot(munis_renta_clean) +
geom_sf(aes(fill = cut(`2019`, fisher$brks)), color = NA) +
scale_fill_viridis_d(option= "A" ,
labels= scales::label_number(suffix= "€")) +
guides(fill = guide_colorsteps()) +
labs(fill= "Fisher-Jenks") +
theme_minimal()
